<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
    <meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1">
    <meta name=viewport content="width=device-width, initial-scale=1">
    <title>ACE中线程的创建和管理 &#8211; 西电托儿所</title>
    <meta name="description" content="       Contents    ">
    <meta name="keywords" content="ACE">
    <link rel="canonical" href="/ACE%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86/">
        <!-- Twitter Cards -->
    <meta name="twitter:title" content="ACE中线程的创建和管理">
    <meta name="twitter:description" content="       Contents    ">
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:image" content="/assets/img/Logo.png">
    <!-- Open Graph -->
    <meta property="og:locale" content="utf-8">
    <meta property="og:type" content="article">
    <meta property="og:title" content="ACE中线程的创建和管理">
    <meta property="og:description" content="       Contents    ">
    <meta property="og:url" content="/ACE%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86/">
    <meta property="og:site_name" content="西电托儿所">
    <meta property="og:image" content="/assets/img/Logo.png">

    
    
    <!-- Handheld -->
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Favicons -->
    <link rel="apple-touch-icon-precomposed" sizes="57x57" href="/assets/img/favicon/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="/assets/img/favicon/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="/assets/img/favicon/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/assets/img/favicon/apple-touch-icon-144x144.png">
    <link rel="icon" type="image/png" href="/assets/img/favicon/favicon.png">
    <link rel="shortcut icon" href="/assets/img/favicon/favicon.ico">
    <!-- Feed -->
    <link rel="alternate" type="application/rss+xml" title="西电托儿所" href="/feed.xml" />
    <!-- CSS -->
    <link rel="stylesheet" type="text/css" href="/assets/css/main.css">
</head>


<body>
        <nav class="nav">
        <ul class="list">
            
				    
				    <li class="item"><a class="link" href="/" >Home</a></li>
				
				    
				    <li class="item"><a class="link" href="/blog/" >Blog</a></li>
				
				    
				    <li class="item"><a class="link" href="/projects/" >Projects</a></li>
				
				    
				    <li class="item"><a class="link" href="/about/" >About</a></li>
				
        </ul>
    </nav>

    <div class="wrapper">
        <div class="title">
            <h1>ACE中线程的创建和管理</h1>
            <h4>21 Jun 2015</h4>
        </div>
        <div class="article">
            <section id="table-of-contents" class="toc">
  <header>
    <h3><i class="fa fa-book"></i> Contents</h3>
  </header>
<div id="drawer">
<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">目的</a></li>
  <li><a href="#ace" id="markdown-toc-ace">用于创建和管理线程的ACE类</a>    <ul>
      <li><a href="#acethreadmanager" id="markdown-toc-acethreadmanager">ACE_Thread_Manager类</a>        <ul>
          <li><a href="#section-1" id="markdown-toc-section-1">另一种创建线程的机制</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#section-2" id="markdown-toc-section-2">结束语</a></li>
</ul>

  </div>
</section>
<!-- /#table-of-contents -->

<p>[1:42 PM]</p>

<h1 id="section">目的</h1>

<p>有过在不同的操作系统下用c++进行过多线程编程的朋友对那些线程处理的API可能深有体会，这些API提供了相同或是相似的功能，但是它们的API的差别却极为悬殊，十分令人头痛。ACE_Thread提供了对不同OS的线程调用的简单包装，通过一个通用的接口进行处理线程创建、挂起、取消和删除等问题。</p>

<h1 id="ace">用于创建和管理线程的ACE类</h1>

<p>1、ACE_Thread_Manager：这是负责创建、管理和同步线程的主要的类。每种操作系统在处理线程方面有细微差异，这个类对应用程序开发人员隐藏这些差异。</p>

<p>2、ACE_Sched_Params:使用这个类管理各个线程的调度优先级，调度优先级是在 ACE 源代码发行版的 ace/Sched_Params.h 头文件中定义的。可以采用不同的调度策略，可以是 “先到先服务” 的循环方式。</p>

<p>3、ACE_TSS:在多线程应用程序中使用全局变量会导致同步问题。</p>

<p>4、ACE_TSS:类提供与线程相关的存储模式，可以对那些对于程序是全局的，但是对于每个线程私有的数据提供抽象。</p>

<h2 id="acethreadmanager">ACE_Thread_Manager类</h2>
<p>本文主要介绍ACE_Thread_Manager类，因为在平时用它也是比较多的。其提供如下的功能：</p>

<p>a）它可以生成一个或更多线程，每个线程运行自己指定的函数。</p>

<p>b）它可以作为一个集合（称为 线程组）管理相关的线程。</p>

<p>c）它管理各个线程的调度优先级。</p>

<p>e）它允许在线程之间进行同步。</p>

<p>f）它可以修改线程属性，比如堆栈大小。</p>

<hr />

<p><strong>以下用类似于这种方式来说明类的方法：方法名（说明）</strong></p>

<ol>
  <li>instance（ACE_Thread_Manager类是一个单实例类，使用这个方法访问线程管理器的惟一实例。）</li>
  <li>spawn（这个方法创建一个新线程，它的一个输入参数是 C/C++函数指针，这个函数执行应用程序的特定工作。）</li>
  <li>exit（这个方法终止一个线程，释放这个线程的所有资源。）</li>
  <li>spawn_n（这个方法创建属于同一个线程组的多个线程。）</li>
  <li>close（这个方法关闭已经创建的所有线程并释放它们的资源。）</li>
  <li>suspend（线程管理器暂停指定的线程。）</li>
  <li>resume（线程管理器恢复执行前面暂停的线程。）</li>
</ol>

<hr />

<p><strong>注意：可以作为单实例类使用 ACE_Thread_Manager类，也可以创建这个类的多个实例。对于单一实例，通过调用 instance方法访问实例。如果需要管理多个线程组，可以创建不同的线程管理器类，每个类控制它自己的线程集。</strong></p>

<p>不说了那么多，直接上码：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>#include "ace/config.h"
#include "ace/Thread_Manager.h"
#include "ace/ACE.h"
#include &lt;iostream&gt;

using namespace std;

ACE_THR_FUNC_RETURN svc( void * argv)
{
	int nCount = 1000;
	for ( int i = 0; i &lt; nCount ; ++i )
	{
		cout&lt;&lt;"now:="&lt;&lt;i&lt;&lt;endl;
	}
	return NULL;
}
    
int main(int, char *[])
{
	ACE_Thread_Manager::instance()-&gt;spawn(svc , NULL);
	ACE_Thread_Manager::instance()-&gt;wait();
	return 0;
};
</code></pre>
</div>

<p>结果为打印出来了1~1000的次数。</p>

<p>初步使用，主要说说这个spawn（）函数，因为其是用于创建线程。其的原型如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>int spawn ( ACE_THR_FUNC func,
            void *arg = 0,
 			long flags = THR_NEW_LWP | THR_JOINABLE | THR_INHERIT_SCHED,
 			ACE_thread_t *t_id = 0,
 			ACE_hthread_t *t_handle = 0,
 			long priority = ACE_DEFAULT_THREAD_PRIORITY,
 			int grp_id = -1,
 			void *stack = 0,
 			size_t stack_size = ACE_DEFAULT_THREAD_STACKSIZE,
 			const char** thr_name = 0);
</code></pre>
</div>

<p>各个参数的作用：</p>

<ul>
  <li>ACE_THR_FUNC func：这是在生成线程时调用的函数。</li>
  <li>void* arg：这是在生成线程时调用的函数的参数。（void*意味着用户可以传递应用程序特有的任何数据类型，甚至可以使用某种结构把多个参数组合成单一数据。 ）</li>
  <li>long flags：使用 flags变量设置生成的线程的几个属性。各个属性都由单一位表示，按照 “或” 关系组合在一起。</li>
  <li>ACE_thread_t *t_id：使用这个函数访问创建的线程的 ID。每个线程具有惟一的 ID。</li>
  <li>long priority：这是生成的线程的优先级。</li>
  <li>int grp_id：如果提供这个参数，那么它表示生成的线程是否属于现有的某一线程组。如果传递 -1，那么创建新的线程组并在这个组中添加生成的线程。</li>
  <li>void* stack：这是预先分配的堆栈区域的指针。如果提供 0，就请求操作系统提供生成的线程的堆栈区域。</li>
  <li>size_t stack_size：这个参数指定线程堆栈的大小（字节数）。如果对于前一个参数（堆栈指针）指定了 0，那么请求操作系统提供大小为 stack_size的堆栈区域。</li>
  <li>
    <p>const char** thr_name：这个参数只与支持线程命名的平台（比如 VxWorks）相关。对于 UNIX 平台，在大多数情况下忽略它。</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>  void print (void* args)

  {

      int id = ACE_Thread_Manager::instance()-&gt;thr_self();
      cout &lt;&lt; "Thread Id: " &lt;&lt; id &lt;&lt; endl;
  }

  int main(int, char *[])

  {
</code></pre>
    </div>

  	ACE_Thread_Manager::instance()-&gt;spawn_n(
  		4, (ACE_THR_FUNC) print, 0, THR_JOINABLE | THR_NEW_LWP);

  	ACE_Thread_Manager::instance()-&gt;wait();
  	return 0;
  	}
  </li>
</ul>

<h3 id="section-1">另一种创建线程的机制</h3>

<p>本节讨论 ACE 提供的另一种线程创建/管理机制。这种方法不需要对线程管理器进行显式的细粒度的控制。在默认情况下，每个进程在创建时有一个线程，这个线程在 main函数开始时启动，在 main结束时终止。其他线程都需要显式地创建。创建线程的另一种方式是创建预定义的 ACE_Task_Base
类的子类，然后覆盖 svc()方法。新线程在 svc()方法中启动，在 svc()
方法返回时终止。</p>

<p>先上码：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>#include "ace/Task.h"
#include &lt;iostream&gt;
using namespace std;
class CThread:public ACE_Task_Base
{
public:
	virtual int svc( )
	{
		cout&lt;&lt;"In Child's thread\n";
		return 0;
	}
};
int main(int, char *[])
{

	CThread cthTest;
	cthTest.activate(THR_NEW_LWP|THR_JOINABLE);
	cthTest.wait();
	return 0;
}
</code></pre>
</div>

<p>说明：
在 svc()方法中编写与应用程序相关的线程行为。通过调用 activate()
方法（在 ACE_Task_Base类中声明和定义）执行线程。在激活线程之后，
main()函数等待子线程完成执行。这就是 wait()方法的作用：在 cthTest执行完之前，主线程被阻塞。这一等待过程是必需的；否则，主线程会调度子线程并执行退出。在看到主线程退出时，运行时会销毁所有子线程；因此，子线程可能根本没有被调度或执行。</p>

<p>ACE_Task_Base::activate 方法的原型</p>

<div class="highlighter-rouge"><pre class="highlight"><code>virtual int activate (
long flags = THR_NEW_LWP | THR_JOINABLE |THR_INHERIT_SCHED,
int n_threads = 1,
int force_active = 0,
long priority = ACE_DEFAULT_THREAD_PRIORITY,
int grp_id = -1,
ACE_Task_Base *task = 0,
ACE_hthread_t thread_handles[ ] = 0,
void *stack[ ] = 0,
size_t stack_size[ ] = 0,
ACE_thread_t thread_ids[ ] = 0,
const char* thr_name[ ] = 0);
</code></pre>
</div>

<p>activate()方法创建一个或多个线程，每个线程调用相同的 svc()方法，所有线程采用相同的优先级并具有相同的组 ID。</p>

<h1 id="section-2">结束语</h1>
<p>注意这里简要介绍了如何使用ACE来创建和管理线程。</p>


        </div>
    </div>
        <div class="footer">
        西电托儿所 © 2016 <a href="/feed.xml" target="_blank"><i class="fa fa-fw fa-feed"></i></a>
    </div>

    <script src="/assets/js/jquery-1.12.2.min.js"></script>
<script src="/assets/js/jquery.goup.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){
    $.goup({
        trigger: 500,
        bottomOffset: 10,
        locationOffset: 20,
        containerRadius: 0,
        containerColor: '#fff',
        arrowColor: '#000',
        goupSpeed: 'normal'
    });
});
</script>


</body>
</html>
