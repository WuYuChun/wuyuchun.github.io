<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
    <meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1">
    <meta name=viewport content="width=device-width, initial-scale=1">
    <title>关于C++思考（六） &#8211; 西电托儿所</title>
    <meta name="description" content="       Contents    ">
    <meta name="keywords" content="C++">
    <link rel="canonical" href="/%E5%85%B3%E4%BA%8EC++%E6%80%9D%E8%80%83-%E5%85%AD/">
        <!-- Twitter Cards -->
    <meta name="twitter:title" content="关于C++思考（六）">
    <meta name="twitter:description" content="       Contents    ">
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:image" content="/assets/img/Logo.png">
    <!-- Open Graph -->
    <meta property="og:locale" content="utf-8">
    <meta property="og:type" content="article">
    <meta property="og:title" content="关于C++思考（六）">
    <meta property="og:description" content="       Contents    ">
    <meta property="og:url" content="/%E5%85%B3%E4%BA%8EC++%E6%80%9D%E8%80%83-%E5%85%AD/">
    <meta property="og:site_name" content="西电托儿所">
    <meta property="og:image" content="/assets/img/Logo.png">

    
    
    <!-- Handheld -->
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Favicons -->
    <link rel="apple-touch-icon-precomposed" sizes="57x57" href="/assets/img/favicon/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="/assets/img/favicon/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="/assets/img/favicon/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/assets/img/favicon/apple-touch-icon-144x144.png">
    <link rel="icon" type="image/png" href="/assets/img/favicon/favicon.png">
    <link rel="shortcut icon" href="/assets/img/favicon/favicon.ico">
    <!-- Feed -->
    <link rel="alternate" type="application/rss+xml" title="西电托儿所" href="/feed.xml" />
    <!-- CSS -->
    <link rel="stylesheet" type="text/css" href="/assets/css/main.css">
</head>


<body>
        <nav class="nav">
        <ul class="list">
            
				    
				    <li class="item"><a class="link" href="/" >Home</a></li>
				
				    
				    <li class="item"><a class="link" href="/blog/" >Blog</a></li>
				
				    
				    <li class="item"><a class="link" href="/projects/" >Projects</a></li>
				
				    
				    <li class="item"><a class="link" href="/about/" >About</a></li>
				
        </ul>
    </nav>

    <div class="wrapper">
        <div class="title">
            <h1>关于C++思考（六）</h1>
            <h4>18 Apr 2015</h4>
        </div>
        <div class="article">
            <section id="table-of-contents" class="toc">
  <header>
    <h3><i class="fa fa-book"></i> Contents</h3>
  </header>
<div id="drawer">
<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">前言</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">多态性</a>    <ul>
      <li><a href="#section-2" id="markdown-toc-section-2">问题</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">捆绑的概念</a></li>
      <li><a href="#section-4" id="markdown-toc-section-4">解析</a></li>
      <li><a href="#c" id="markdown-toc-c">C++如何实现这种机制</a></li>
    </ul>
  </li>
</ul>

  </div>
</section>
<!-- /#table-of-contents -->

<p>[10:54 AM]</p>

<h1 id="section">前言</h1>
<p>多态性（在 C + +中用虚函数实现）是面向对象程序设计语言继数据抽象和继承之后的第三个基本特征。
封装是通过特性和行为的组合来创建新数据类型的，通过让细节private来使得接口与具体实现相隔离。这类机构对于有过程程序设计背景的人来说是非常有意义的。而虚函数则根据类型的不同来进行不同的隔离。
那么虚函数和前面讲到的继承的区别在与那里：
1、继承如何允许把对象作为它自己的类型或它的基类类型处理。这个能力很重要，因为它允许很多类型（从同一个基类派生的）被等价地看待就象它们是一个类型，允许同一段代码同样地工作在所有这些不同类型上。
2、虚函数反映了一个类型与另一个类似类型之间的区别，只要这两个类型都是从同一个基类派生的。这种区别是通过其在基类中调用的函数的表现不同来反映的。
（注意这两者的区别和联系~~~）</p>

<blockquote>
  <p>C + +程序员的进步
第一步：简单地把 C + +作为一个“更好的 C”，因为 C + +在使用任何函数之前必须声明它，并且对于如何使用变量有更苛刻的要求。简单地用 C + +编译器编译 C程序常常会发现错误。 
第二步：进入“面向对象”的 C ++。这意味着，很容易看到将数据结构和在它上面活动的 函数捆绑在一起的代码组织，看到构造函数和析构函数的价值，也许还会看到一些简单的继承， 这是有好处的。许多用过 C的程序员很快就知道这是有用的，因为无论何时，创建库时，这些 都是要做的。然而在 C ++中，由编译器来帮我们完成这些工作。 在基于对象层上，我们可能受骗，因为无须花费太多精力就能得到很多好处。它也很容易 使我们感到正在创建数据类型—制造类和对象，向这些对象发送消息，一切漂亮优美。 但是，不要犯傻，如果我们停留在这里，我们就失去了这个语言的最重要的部分。这个最 重要的部分才真正是向面向对象程序设计的飞跃。要做到这一点，只有靠第三步。
第三步：使用虚函数。虚函数加强类型概念，而不是只在结构内和墙后封装代码，所以毫 无疑问，对于新 C ++程序员，它们是最困难的概念。然而，它们也是理解面向对象程序设计的 转折点。如果不用虚函数，就等于还不懂得 O O P。</p>
</blockquote>

<h1 id="section-1">多态性</h1>

<h2 id="section-2">问题</h2>
<p>从之前了解到，使用继承的话（public），派生类可以通过使用基类，
因为基类所有的接口，派生类也有，向上映射的话，派生类的接口会缩小到其基类的接口。调用派生类的接口，若是一个函数是基类的参数，则不需要转换，直接调用，但是输出的是基类的内容，而不是派生类的内容。</p>

<h2 id="section-3">捆绑的概念</h2>
<p>把函数体与函数调用相联系称为捆绑（ b i n d i n g）。当捆绑在程序运行之前（由编译器和连接器）完成时，称为早捆绑。因为在过程语言中是不会有的：C编译只有一种函数调用，就是早捆绑。
晚捆绑，这意味着捆绑在运行时发生，基于对象的类型。晚捆绑又称为动
态捆绑或运行时捆绑。当一个语言实现晚捆绑时，必须有一种机制在运行时确定对象的类型和合适的调用函数。这就是，编译器还不知道实际的对象类型，但它插入能找到和调用正确函数体的代码。晚捆绑机制因语言而异，但可以想象，一些种类的类型信息必须装在对象自身中。
<strong>为了引起晚捆绑， C + +要求在基类中声明这个函数时使用 v i r t u a l关键字。晚捆绑只对 v i r t u a l起作用，而且只发生在我们使用一个基类的地址时，并且这个基类中有v i r t u a l函数，尽管它们也可以在更早的基类中定义。</strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code>enum note {middC, Csharp, Cflat};
class instrument
{
	public:
		virtual void play(note) const
		{
			cout &lt;&lt;"instrument::play"&lt;&lt;endl;
		}
};
class wind : public instrumen
{
	public:
		void play(note)const
		{
			cout&lt;&lt;"wind:play"&lt;&lt;endl;
		}
};
void tune(instrument &amp;i)
{
	i.play(middleC);
}
int main(void)
{
	wind flute;
	tune(flute);//向上映射！
}
</code></pre>
</div>

<h2 id="section-4">解析</h2>
<p>通过将play( ) 在基类中定义为 v i r t u a l，不用改变t u n e ( )函数就可以在系统中随意增加新函数。在一个设计好的 O O P程序中，大多数或所有的函数都沿用 t u n e ( )模型，只与基类接口通信。这样的程序是可扩展的，因为可以通过从公共基类继承新数据类型而增加新功能。操作基类接口的函数完全不需要改变就可以适合于这些新类。
<strong>可以从log4Cpp的了解，Appender类派生了ConsoleAppender和FileAppender等类</strong></p>

<h2 id="c">C++如何实现这种机制</h2>
<p><strong>可以查看《深度探索C++对象模型》这是非常经典的书！！！！值得一读！！！！</strong></p>

        </div>
    </div>
        <div class="footer">
        西电托儿所 © 2016 <a href="/feed.xml" target="_blank"><i class="fa fa-fw fa-feed"></i></a>
    </div>

    <script src="/assets/js/jquery-1.12.2.min.js"></script>
<script src="/assets/js/jquery.goup.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){
    $.goup({
        trigger: 500,
        bottomOffset: 10,
        locationOffset: 20,
        containerRadius: 0,
        containerColor: '#fff',
        arrowColor: '#000',
        goupSpeed: 'normal'
    });
});
</script>


</body>
</html>
