---
layout: post
title:  "C++错误思考(4)"
date:   2016-09-07 11:15 PM
excerpt:
tag:
- C++
---

{% include toc.html %}

[11:11 PM PM]


# 前言
C++是一个静态类别的语音，也就是说在编译的时候，会对其类型进行检查。但是C++又是一个灵活性极高的语言，因此就是
出现**破坏静态类型安全的编码**。

# 第一种情况：以void *为主导
在强制类型转换中，转换到void *类型的结果会将类型的指针的类型信息都会抹除。同时，存在的情况是，基类与派生类之间的转换。
在《探索C++内存模型》中说道基类与派生类之间的内存模型。如下：

|  |          
|:---|        
|基类class子对象|  
|派生类成员|

当然这是在单继承情况下。若是多继承呢？ *在多继承条件下，单一对象往往有多个合法地址*

|  |
|:-----|
|基类subject类型的子对象|
|基类button类型的子对象|
|派生类成员|

>在接口中使用void *作为类型转换的中介类型，并要求用户在调用接口中的某一个函数时重新提供另一个函数抹除的类型信息，
这终究不是办法

# 第二种 截断问题

发生的时机：*企图把一个派生类对象的内容复制到另一个基类对象的存储的时刻*
发生的后果：*那些派生类型专属的成员数据和成员函数会被截断*。

```
class Employee{
public:
    vitual ~Employee();
    vitual void pay() const;
protect:
    void setType( int type){
        myType_ = type;
    }
private:
    int myType_ ; //不好的的用法
};

calss Salaried:public Employee{
    //...
};

Employee employee;
Salaried salaried;
employee = salaried; //发生什么，截断了

```

*Salaried 类型信息完全被隔离，虚函数表中根本没有放入Salaried类型所指定对应函数入口地址*

这里也提出一个问题：在设计的时候，要保证截断情况保持赋值结果的状态的合法性。

----
截断问题的最常见来源，是一个派生类的class类对象被以传值方式传递给一个基类的形参

```
void fire( Employee victim);
fire(salaried); //被截断

```
**解决方法：传递引用或指针**
----

---------------------------
----------------------------

# 赋值和初始化
**初始化：把一段新鲜存储（raw storage）变成一个对象的过程，对于一个class对象来说，这会涵盖搭建一系列内部机能，以
支持虚函数和虚基类、运行时类别信息以及其他类别相依的信息**

**赋值 是一个有着合适定义对象的某种状态上所作的一个变化，使该对象处于一个新的状态，赋值操作不会实现对象的类型相依的
行为背后的内部机能**

复制构造和复制赋值的区别，（浅层复制 和 深层赋值）

```

struct X{
    int *t_;
    X &operator = (const X &rhs){
        if( this != &rhs ){
            delete t_; //！删除一段未定义的内存，作死～～～
            t_ = new int(*rhs.t_);
        }
        return  *this;
    }
};


int main() {
    X x;
    X *buf = (X *)malloc(sizeof(X)); // 申请内存，初始化了吗？
    X &rx = *buf;
    rx = x;  //！出现段错误
    return 0;
}

```
