# 内存受限系统之软件开发



## 简介

模式是“特定环境中的问题解答”

优秀的模式不是发明出来的，而是从既有系统和实践中挖出来的

本书的模式主要关注：

- 内存需求：系统占用的内存总量
- 内存可预测性：内存需求量能否事先决定
- 实时反应
- 启动时间
- 局部vs整体
- 时间效率：有助于提升系统执行速度
- 辅助存储设备
- 易维护性
- 程序员心力
- 测试成本
- www.smallmemory.com：实例代码

系统体系结构：

- 并不仅限于高阶组件的设计，以及组件间的相互连接
- 系统体系结构策略，包括组件共同政策，标准和假设
- 环境（编译工具和运行时系统）越复杂，程序员需要负担的内存管理工作越少



## 5大内容



- 小容量体系结构：需要系统内多个组件协作才能完成内存节约技术
  - 内存限额: 为组件可分配的内存数量设一个上限
    - 如何在相互竞争的组件之间分配内存
    - 为每一个组件设置限额，对于超出限额的请求，拒绝
  - small interface:介于组件之间
    - 如何减少组件接口带来的内存额外开销？
    - 接口之间的数据传输量最少
  - partial failure:局部毁弃，降格求全
    - 如何处理不可预见的内存需求？
    - 确保内存消耗殆尽也要让系统处于安全状态
  - captain oates：牺牲小我
    - 如何满足对内存的最重要需求？
  - read only memory：只读内存
    - 如何处置只读的代码和数据
  - hooks：挂钩
    - 如何更改只读存储器内的信息？
    - 通过hooks访问只读信息，然后更改hooks，以便造成信息更改的假象
- 辅助存储设备：以硬盘或等价物来辅助
  - 任务切换
    - 面对提供许多不同函数的系统，你如何降低其内存需求？
    - 把系统分解成独立执行体，每一次只运行一个
  - 纯数据文件
    - 如何数据量太大，主内存容纳不下怎么办？
    - 一次只处理一部分数据，其余放在辅助存储设备
  - 纯资源文件
    - 如何管理为数总多的配置数据
  - 封包
    - 如何管理“有许多可选成分”的大型程序
  - 分页
    - 如何制造出内存数量无限的幻象中？
- 压缩：通过“自压缩”来减少数据量
  - 关键理念：多数数据包含大量的冗余
    - 机械冗余
    - 语义冗余
    - 有损压缩：区分数据和信息
  - 压缩的书籍：managing gigabytes
    - information engineering across the professions
  - 表格压缩
    - 如何压缩大量短字符串？
  - 差分编码
    - 如何减少序列数据所占用的内存？
    - 根据相邻两笔数据之间的差异来表现序列
  - 自省式压缩
    - 如何降低大量大型数据的内存需求？
    - 运用adaptive compression
- 小型数据结构：定义好的数据结构
  - 数据打包
    - 如何缩减存储一个数据结构所需的内存？
    - 打包结构内的数据项，使它们占用最小空间
  - 共享
    - 如何避免同一份信息产生出多份副本信息？
    - 一份信息只存储一次，任何需要它的地方，共享同一份信息
  - 临写复制
    - 如何改变共享对象而不影响其他客户
  - 内嵌式指针
    - 如何缩小一整群对象所占用的空间？
  - 多重表述
    - 如何支持同一种对象的多种不同实现呢？
    - 让所有实现都满足共同接口
- 内存分配在无序的内存中创建某种数据结构，并在不需要的时候，反还内存
  - 设计内存分配机制，需要考虑一些议题
    - 碎片
      - 内部碎片：一个数据结构未用完它所配的的全部内存
      - 外部碎片
    - 内存耗尽
  - 固定式分配
    - 如何确保永远不至于无内存可用？
    - 在初始化阶段预先分配对象
  - 可变式分配
    - 如何避免出现未被运用的无意义内存空间
    - 只有当你需要的时候，才分配或者归还大小不定的对象
  - 内存抛弃
    - 如何分配暂态对象
    - 在暂态工作区中分配对象，用完后丢弃
  - 池式分配
    - 如何分配大量像式的对象？
    - 预先分配一个对象池，循环使用其中“未被使用的对象”
  - 引用计数
  - 垃圾回收机制





















