Linux主线内核之外的两个非常有意思的适合桌面使用的task调度器BFS和MuqSS,BFS不是一个普适的task调度器，相反，它仅仅适用于桌面交互的环境。所以，为你的水冷游戏机使用BFS，而不是在携带众核CPU嗡嗡作响的2U服务器上使用它。MuqSS则是BFS的改进版。MuqSS的全称是 Multiple Queue Skiplist Scheduler。

BFS的核心数据结构非常简单，就是普通双向链表，每次选择task时，该链表会被遍历，具有最小 Virtual Deadline 的task将会被选中。
 显然，这个过程的时间复杂度是O(n)。其中， Virtual Deadline 的计算方法如下：

```shell
Virtual Deadline = jiffies + (user_priority * rr_interval)
```

BFS虽然简单，但是两个问题却非常明显：

1. *遍历查找的O(n)问题。* 链表为什么不基于Virtual Deadline进行预排序呢？
2. *多CPU操作全局链表的锁问题。*

众所周知， *“O(n)时间复杂度和锁”* 在计算机领域一直饱受诟病，它们似难兄难弟一般的存在。BFS却毫不忌讳地同时将它们采纳到自己的核心算法中。

对此，Con Kolivas的解释就是 *保持实现的简单：*

> 启发式的复杂算法终究还是启发式的，总是伴随误判。在单一的环境中，与其以庞大的代码量维持不必要的启发式算法，不如放弃启发式算法，退回到最简单的数据结构和代码实现。 既然那些复杂的调度算法没有带来让人期望的收益，为什么不试试最简单的方法呢？即便同样糟糕，至少代码简单了不是吗？



如果要实现Virtual Deadline的预排序，必然要在下面二者之间作出权衡：

1. 链表操作的O(n)时间复杂度代价。
2. 复杂数据结构实现的代价和副作用。

最终，Con Kolivas认为：

1. *在task数量并不太大的情况下，O(n)算法没有任何问题。*
2. *在CPU数量保持在16个以内时，争锁的开销可以忽略。*

因此，没有必要为了可以忽略不计的问题而付出复杂性的代价。

所以，**结论是BFS很好，它显示出了一种干练。**有人如此评价BFS， *“快 ！人能感觉到的快！”*

问题确实存在，Con Kolivas只是觉得为了解决那些在桌面环境下不足以带来严重影响的问题而以引入复杂性为代价，这不值得。 *除非可以在保持简单的前提下零代价解决问题！*

有这样的方案吗？

当然有！这就是[[2021-03-21-linux调度算法Muqss]]MuqSS的算法！