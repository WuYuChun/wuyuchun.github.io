# c++æ¨¡æ¿å…ƒç¼–ç¨‹å®æˆ˜ï¼ˆä¸€ä¸ªæ·±åº¦å­¦ä¹ æ¡†æ¶çš„å®ç°ï¼‰

[TOC]





## å‰è¨€

- æ•´åˆå…ƒç¼–ç¨‹æŠ€æœ¯ï¼Œé€šè¿‡ç¼–è¯‘æœŸè®¡ç®—ä¸ºè¿è¡ŒæœŸä¼˜åŒ–æä¾›æ›´å¤šçš„å¯èƒ½
- å‡½æ•°é‡è½½åªæ˜¯ä¸€ç§ç®€å•çš„ç¼–è¯‘è®¡ç®—ï¼Œä½†æ˜¯åœ¨è¿›è¡Œç¼–è¯‘çš„æ—¶å€™ï¼Œå¦‚ä¸‹ç¼–è¯‘å™¨è¿›è¡Œé€‰æ‹©åˆé€‚çš„å‡½æ•°

```c++
Matrix Add(const AbstractMatrix *mat1, const AbstractMatrix *mat2);
Matrix Add(const ZeroMatrix *mat1, const AbstractMatrix *mat2);
```

- **ä½¿ç”¨æ¨¡æ¿æ¥æ„é€ è‹¥å¹²ç»„ä»¶ï¼Œå…¶ä¸­æ˜¾ç¤ºåŒ…å«äº†éœ€è¦ç¼–è¯‘å™¨å¤„ç†çš„é€»è¾‘ï¼Œç¼–è¯‘å™¨ä½¿ç”¨è¿™äº›æ¨¡æ¿æ‰€æ¨å¯¼å‡ºæ¥çš„å€¼ï¼ˆæˆ–ç±»å‹ï¼‰æ¥ä¼˜åŒ–ç³»ç»Ÿï¼Œè¿™ç§ç”¨æ¥ç¼–è¯‘æœŸè®¡ç®—çš„æ¨¡æ¿è¢«ç§°å…ƒå‡½æ•°ï¼Œç›¸åº”çš„è®¡ç®—æ–¹æ³•ä¹Ÿè¢«ç§°ä¸ºå…ƒç¼–ç¨‹æˆ–è€…æ¨¡æ¿ç¼–ç¨‹**

å…ƒç¼–ç¨‹ä¸ç¼–è¯‘æœŸè®¡ç®—çš„ä¼˜åŠ¿ä¹‹ä¸€ï¼š

- æ›´å¥½åœ°åˆ©ç”¨è¿ç®—æœ¬èº«çš„ä¿¡æ¯ï¼Œæå‡ç³»ç»Ÿæ€§èƒ½

æ·±å…¥ä½¿ç”¨å…ƒç¼–ç¨‹æŠ€æœ¯ï¼Œä¸€ä¸ªéšä¹‹è€Œæ¥çš„é—®é¢˜å°±æ˜¯ç¼–è¯‘æœŸä¸è¿è¡ŒæœŸçš„äº¤äº’

å…ƒç¼–ç¨‹åº”ç”¨æˆæœ¬ï¼š

- è¦å»ºç«‹å‡½æ•°å¼ç¼–ç¨‹çš„æ€ç»´æ¨¡å¼ï¼Œ*ä»€ä¹ˆæ˜¯å‡½æ•°å¼ç¼–ç¨‹ï¼Ÿ*
- è°ƒè¯•å›°éš¾
- äº¤ä»˜ä»–äººä½¿ç”¨ï¼Œæ¨¡æ¿æäº¤å¤´æ–‡ä»¶ï¼ˆæœ‰å®ç°å®šä¹‰ï¼Œä¼šæ³„æ¼ç›¸åº”çš„é€»è¾‘ï¼‰





## åŸºæœ¬æŠ€å·§

ç¼–è¯‘å™¨ä¸è¿è¡ŒæœŸæ‰€ä½¿ç”¨â€œå‡½æ•°â€çš„å¼‚åŒ



### å…ƒå‡½æ•°çš„ä»‹ç»

c++å…ƒç¼–ç¨‹æ˜¯ä¸€ç§å…¸å‹çš„å‡½æ•°å¼ç¼–ç¨‹ï¼Œå‡½æ•°åœ¨æ•´ä¸ªç¼–ç¨‹ä½“ç³»ä¸­å¤„äºæ ¸å¿ƒçš„åœ°ä½

è¿™é‡Œæ‰€å®šä¹‰çš„å‡½æ•°ä¸ä¸€èˆ¬c++ç¨‹åºä¸­å®šä¹‰ä¸ä½¿ç”¨çš„å‡½æ•°æœ‰æ‰€åŒºåˆ«ï¼Œæ›´æ¥è¿‘æ•°å­¦æ„ä¹‰ä¸Šçš„å‡½æ•°-æ˜¯æ— å‰¯ä½œç”¨çš„æ˜ å°„æˆ–å˜æ¢ï¼š**åœ¨è¾“å…¥ç›¸åŒçš„å‰æä¸‹ï¼Œå¤šæ¬¡è°ƒç”¨åŒä¸€ä¸ªå‡½æ•°ï¼Œå¾—åˆ°çš„ç»“æœä¹Ÿæ˜¯ç›¸åŒçš„**

*å¦‚æœå‡½æ•°å­˜åœ¨å‰¯ä½œç”¨ï¼Œé‚£ä¹ˆé€šå¸¸æ˜¯ç”±äºå­˜åœ¨æŸäº›ç»´æŠ¤äº†ç³»ç»ŸçŠ¶æ€çš„å˜é‡è€Œå¯¼è‡´çš„ã€‚æ¯æ¬¡å‡½æ•°è°ƒç”¨æ—¶ï¼Œå³ä½¿è¾“å…¥ç›¸åŒï¼Œä½†ç³»ç»ŸçŠ¶æ€çš„å·®å¼‚ä¼šå¯¼è‡´å‡½æ•°è¾“å‡ºç»“æœä¸åŒï¼šè¿™æ ·çš„å‡½æ•°è¢«ç§°ä¸ºå…·æœ‰å‰¯ä½œç”¨çš„å‡½æ•°ã€‚*

**å…ƒå‡½æ•°ä¼šåœ¨ç¼–è¯‘å™¨è¢«è°ƒç”¨ä¸æ‰§è¡Œ**ï¼Œåœ¨ç¼–è¯‘é˜¶æ®µï¼Œç¼–è¯‘å™¨åªèƒ½æ„é€ å¸¸é‡ä½œä¸ºå…¶ä¸­é—´ç»“æœï¼Œæ— æ³•æ„é€ å¹¶ç»´æŠ¤å¯ä»¥è®°å½•ç³»ç»ŸçŠ¶æ€å¹¶éšä¹‹æ”¹å˜çš„é‡ï¼Œå› æ­¤ç¼–è¯‘å™¨å¯ä»¥ä½¿ç”¨çš„å‡½æ•°ï¼ˆå³å…ƒå‡½æ•°ï¼‰åªèƒ½æ˜¯æ— å‰¯ä½œç”¨çš„å‡½æ•°

```c++
constexpr int fun(int a){
    return a+1;
}
```

å…ƒå‡½æ•°çš„ç±»å‹ï¼š

+ æ•°å€¼å…ƒå‡½æ•°
+ ç±»å‹å…ƒå‡½æ•°ï¼šä»¥ç±»å‹ä½œä¸ºè¾“å…¥ï¼ˆæˆ–è¾“å‡ºï¼‰çš„å…ƒå‡½æ•°

> å…ƒå‡½æ•°å¾—å®šä¹‰
>
> ğŸš©å…·æœ‰è¾“å…¥ï¼ˆTï¼‰ï¼Œè¾“å‡º
>
> ğŸš©å…·æœ‰æ˜ç¡®å®šä¹‰æ˜ å°„è§„åˆ™ï¼Œæ— å‰¯ä½œç”¨ï¼Œå¯ä»¥åœ¨ç¼–è¯‘å™¨è¢«è°ƒç”¨



## type_traits

å…ƒå‡½æ•°åº“ï¼Œè¿™ä¸ªåº“å®ç°ç±»å‹å˜åŒ–ã€ç±»å‹æ¯”è¾ƒä¸åˆ¤æ–­ç­‰åŠŸèƒ½



> *C++æ ‡å‡†æ¨¡æ¿åº“*

**å…ƒå‡½æ•°å¯ä»¥æ“ä½œç±»å‹ä¸æ•°å€¼ï¼›å¯¹äºå…ƒå‡½æ•°æ¥è¯´ï¼Œç±»å‹ä¸æ•°å€¼å¹¶æ²¡æœ‰æœ¬è´¨ä¸Šçš„åŒºåˆ«ï¼Œå®ƒä»¬éƒ½å¯ä»¥è§†ä¸ºä¸€ç§â€œæ•°æ®â€ï¼Œå¯ä»¥ä½œä¸ºå…ƒå‡½æ•°çš„è¾“å…¥ä¸è¾“å‡º**

å…ƒå‡½æ•°å¯ä»¥æ“ä½œçš„æ•°æ®ï¼š

- [ ] æ•°å€¼
- [ ] ç±»å‹
- [ ] æ¨¡æ¿

```c++
template <template <typename> class T1, typename T2>
struct Test_ {
    using type = typename T1<T2>::type;
};

Test_<std::remove_reference, int&>::type h = 3;
```

> **æ¨¡æ¿å…ƒç¼–ç¨‹åº“MPLï¼ˆBoost C++ template Meta-Programming libraryï¼‰**

### å®¹å™¨æ¨¡æ¿

```c++
template<int ... Vals> struct IntContainer;
template<typename ...Types> stuct TypeContainer;
template<template<type > class ...T> strcut TemplateConts;
```

è¿™äº›éƒ½æ˜¯å£°æ˜å¹¶éå®šä¹‰ï¼Œè¿™æ˜¯å…ƒç¼–ç¨‹çš„ä¸€ä¸ªç‰¹ç‚¹ï¼Œéœ€è¦å®šä¹‰å—ï¼Ÿä¸éœ€è¦ï¼Œå› ä¸ºå£°æ˜ä¸­åŒ…å«äº†ç¼–è¯‘å™¨æ‰€éœ€è¦ä½¿ç”¨çš„å…¨éƒ¨ä¿¡æ¯

å…ƒç¼–ç¨‹ä¸­çš„ä¸€ä¸ªæƒ¯ç”¨æ³•ï¼š**ä»…åœ¨å¿…è¦æ—¶æ‰å¼•å…¥å®šä¹‰ï¼Œå…¶ä»–çš„æ—¶å€™ç›´æ¥ä½¿ç”¨å£°æ˜å³å¯**



### ç¼–è¯‘å™¨ä¸­çš„é¡ºåºã€åˆ†æ”¯ä¸å¾ªç¯

**æ„æˆæ•´ä¸ªå…ƒç¼–ç¨‹ä½“ç³»çš„æ ¸å¿ƒ**



å®ç°åˆ†æ”¯çš„æ–¹å¼ï¼š

+ ä½¿ç”¨æ¨¡æ¿çš„ç‰¹åŒ–æˆ–è€…éƒ¨åˆ†ç‰¹åŒ–æ¥å®ç°åˆ†æ”¯

  + æ³¨æ„ï¼šåœ¨éå®Œæˆç‰¹åŒ–çš„ç±»æ¨¡æ¿ä¸­å¼•å…¥å®Œå…¨ç‰¹åŒ–çš„åˆ†æ”¯ä»£ç æ˜¯éæ³•çš„
  + 

+ ä½¿ç”¨std::conditional

  + ```c++
    namespace std{
    template<bool B,typename T, typename F>
    	struct conditional{
    		using type = T;
    	};
    template<typename T, typename F>
        struct conditioanl<flase,T,F>{
        	using type = F;
        };
    template<bool B,typename T, typename F>
    using conditona_t = typename conditioan<B,T,F>::type;
    }
    
    std::conditional<true,int,float>::type x = 3;
    std::conditional<flase,int ,float>::type y = 1.0f;ss
    ```

+ std::enable_ifæ¥å®ç°åˆ†æ”¯

> c++ä¸­æœ‰ä¸€ä¸ªç‰¹æ€§SFINAEï¼ŒåŒ¹é…å¤±è´¥å¹¶éé”™è¯¯

- ä½¿ç”¨if constexpr



ä¸€èˆ¬æ¥è¯´ï¼Œä¸ä¼šç”¨while forè¿™æ ·çš„è¯­å¥æ¥ç»„ç»‡å…ƒå‡½æ•°ä¸­çš„å¾ªç¯ä»£ç ï¼Œå› ä¸ºè¿™äº›ä»£ç æ“ä½œçš„æ˜¯å˜é‡ï¼Œä¸ºäº†èƒ½å¤Ÿæœ‰æ•ˆçš„æ“ä½œå…ƒæ•°æ®ï¼Œä¼šä½¿ç”¨é€’å½’çš„å½¢å¼æ¥å®ç°å¾ªç¯ã€‚

```c++
template< size_t Input>
constexprt size_t OnesCount = (Input % 2) + OnesCount<(Input /2)>;
template<> constexpr size_t OnesCount<0> = 0;
constexpr size_t res = OnesCount<45>;
```

**å®ä¾‹åŒ–çˆ†ç‚¸å’Œç¼–è¯‘å´©æºƒ**ï¼šè¿™ä¸ªé—®é¢˜è¦è¶³å¤Ÿçš„é‡è§†

```c++
template <size_t ID>
struct imp{
     constexpr static size_t value = ID + imp<ID-1>::value;
};
template<>
struct imp<0>{
	constexpr static size_t value = 0;
}
template<size_t A>
struct Wrap_{
    template <size_t ID>
    constexpr static size_t value=imp<A+ID>::value;
}
```

å¥‡ç‰¹çš„é€’å½’æ¨¡æ¿å¼ï¼ˆCRTPï¼‰æ˜¯ä¸€ç§æ´¾ç”Ÿç±»çš„å£°æ˜æ–¹å¼ï¼Œå…ƒç¼–ç¨‹æ¶‰åŠçš„å‡½æ•°å¤§éƒ¨åˆ†ä¸æ¨¡æ¿ç›¸å…³ï¼Œæˆ–è€…å¾€å¾€æ˜¯ç±»ä¸­çš„é™æ€å‡½æ•°ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¦‚æœè¦å®ç°ç±»ä¼¼è¿è¡ŒæœŸçš„å¤šæ€ç‰¹æ€§ï¼Œå°±å¯ä»¥è€ƒè™‘ä½¿ç”¨CRTP

### å…·åå‚æ•°

ä½¿ç”¨å…·åå‚æ•°è¿›è¡Œå‡½æ•°è°ƒç”¨ï¼Œå¯ä»¥ä¸€å®šç¨‹åº¦ä¸Šç¯å¢ƒï¼Œä¼ å…¥å‚æ•°çš„é”™è¯¯



#### å¼‚ç±»è¯å…¸çš„å®ç°



ä¸¤ä¸ªæ¦‚å¿µï¼štraitå’Œpolicyï¼Œ traitç”¨äºæè¿°ç‰¹æ€§ï¼Œpolicyç”¨äºæè¿°è¡Œä¸º

> å‚åŠ C++ templatesä¸­æ–‡ç‰ˆ





#### æ”¯é…ä¸è™šç»§æ‰¿

```c++
struct A{
	void fun();
}
struct B :A {
  void fun();
};
struct C:B{
	void wrapper(){
		fun();
	}
}
//è‹¥æ˜¯è°ƒç”¨wrapper ï¼Œä¼šæ‰§è¡Œå“ªä¸ªfun
```



æ ¹æ®C++ä¸­çš„ç»§æ‰¿è§„åˆ™ï¼Œè‹¥æ˜¯Cä¸­æ²¡æœ‰funå®šä¹‰ï¼Œåˆ™ä¼šé¡ºç€ç»§æ‰¿å…³ç³»ï¼Œå¾€ä¸Šå¯»æ‰¾ï¼Œå³B

åœ¨æœç´¢çš„è¿‡ç¨‹ä¸­ï¼Œç¼–è¯‘å™¨ä¼šé€‰æ‹©å…·æœ‰æ”¯é…åœ°ä½çš„å‡½æ•°

åœ¨å¤šé‡ç»§æ‰¿æƒ…å†µä¸‹ï¼Œå…·æœ‰è™šç»§æ‰¿æ‰ä¼šæœ‰æ•ˆï¼Œå¦åˆ™ï¼Œç¼–è¯‘ä¼šæŠ¥å‘Šå‡½æ•°è§£ææœ‰æ­§ä¹‰



#### metaNN

è‡ªåº•å‘ä¸Šåˆ’åˆ†ä¸º4ä¸ªå±‚æ¬¡ï¼š

- [ ] æ•°æ®
- [ ] è¿ç®—
- [ ] å±‚
- [ ] æ±‚å€¼

