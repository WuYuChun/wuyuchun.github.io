# c++æ¨¡æ¿å…ƒç¼–ç¨‹å®æˆ˜ï¼ˆä¸€ä¸ªæ·±åº¦å­¦ä¹ æ¡†æ¶çš„å®ç°ï¼‰

[TOC]





## å‰è¨€

- æ•´åˆå…ƒç¼–ç¨‹æŠ€æœ¯ï¼Œé€šè¿‡ç¼–è¯‘æœŸè®¡ç®—ä¸ºè¿è¡ŒæœŸä¼˜åŒ–æä¾›æ›´å¤šçš„å¯èƒ½
- å‡½æ•°é‡è½½åªæ˜¯ä¸€ç§ç®€å•çš„ç¼–è¯‘è®¡ç®—ï¼Œä½†æ˜¯åœ¨è¿›è¡Œç¼–è¯‘çš„æ—¶å€™ï¼Œå¦‚ä¸‹ç¼–è¯‘å™¨è¿›è¡Œé€‰æ‹©åˆé€‚çš„å‡½æ•°

```c++
Matrix Add(const AbstractMatrix *mat1, const AbstractMatrix *mat2);
Matrix Add(const ZeroMatrix *mat1, const AbstractMatrix *mat2);
```

- **ä½¿ç”¨æ¨¡æ¿æ¥æ„é€ è‹¥å¹²ç»„ä»¶ï¼Œå…¶ä¸­æ˜¾ç¤ºåŒ…å«äº†éœ€è¦ç¼–è¯‘å™¨å¤„ç†çš„é€»è¾‘ï¼Œç¼–è¯‘å™¨ä½¿ç”¨è¿™äº›æ¨¡æ¿æ‰€æ¨å¯¼å‡ºæ¥çš„å€¼ï¼ˆæˆ–ç±»å‹ï¼‰æ¥ä¼˜åŒ–ç³»ç»Ÿï¼Œè¿™ç§ç”¨æ¥ç¼–è¯‘æœŸè®¡ç®—çš„æ¨¡æ¿è¢«ç§°å…ƒå‡½æ•°ï¼Œç›¸åº”çš„è®¡ç®—æ–¹æ³•ä¹Ÿè¢«ç§°ä¸ºå…ƒç¼–ç¨‹æˆ–è€…æ¨¡æ¿ç¼–ç¨‹**

å…ƒç¼–ç¨‹ä¸ç¼–è¯‘æœŸè®¡ç®—çš„ä¼˜åŠ¿ä¹‹ä¸€ï¼š

- æ›´å¥½åœ°åˆ©ç”¨è¿ç®—æœ¬èº«çš„ä¿¡æ¯ï¼Œæå‡ç³»ç»Ÿæ€§èƒ½

æ·±å…¥ä½¿ç”¨å…ƒç¼–ç¨‹æŠ€æœ¯ï¼Œä¸€ä¸ªéšä¹‹è€Œæ¥çš„é—®é¢˜å°±æ˜¯ç¼–è¯‘æœŸä¸è¿è¡ŒæœŸçš„äº¤äº’

å…ƒç¼–ç¨‹åº”ç”¨æˆæœ¬ï¼š

- è¦å»ºç«‹å‡½æ•°å¼ç¼–ç¨‹çš„æ€ç»´æ¨¡å¼ï¼Œ*ä»€ä¹ˆæ˜¯å‡½æ•°å¼ç¼–ç¨‹ï¼Ÿ*
- è°ƒè¯•å›°éš¾
- äº¤ä»˜ä»–äººä½¿ç”¨ï¼Œæ¨¡æ¿æäº¤å¤´æ–‡ä»¶ï¼ˆæœ‰å®ç°å®šä¹‰ï¼Œä¼šæ³„æ¼ç›¸åº”çš„é€»è¾‘ï¼‰





## åŸºæœ¬æŠ€å·§

ç¼–è¯‘å™¨ä¸è¿è¡ŒæœŸæ‰€ä½¿ç”¨â€œå‡½æ•°â€çš„å¼‚åŒ



### å…ƒå‡½æ•°çš„ä»‹ç»

c++å…ƒç¼–ç¨‹æ˜¯ä¸€ç§å…¸å‹çš„å‡½æ•°å¼ç¼–ç¨‹ï¼Œå‡½æ•°åœ¨æ•´ä¸ªç¼–ç¨‹ä½“ç³»ä¸­å¤„äºæ ¸å¿ƒçš„åœ°ä½

è¿™é‡Œæ‰€å®šä¹‰çš„å‡½æ•°ä¸ä¸€èˆ¬c++ç¨‹åºä¸­å®šä¹‰ä¸ä½¿ç”¨çš„å‡½æ•°æœ‰æ‰€åŒºåˆ«ï¼Œæ›´æ¥è¿‘æ•°å­¦æ„ä¹‰ä¸Šçš„å‡½æ•°-æ˜¯æ— å‰¯ä½œç”¨çš„æ˜ å°„æˆ–å˜æ¢ï¼š**åœ¨è¾“å…¥ç›¸åŒçš„å‰æä¸‹ï¼Œå¤šæ¬¡è°ƒç”¨åŒä¸€ä¸ªå‡½æ•°ï¼Œå¾—åˆ°çš„ç»“æœä¹Ÿæ˜¯ç›¸åŒçš„**

*å¦‚æœå‡½æ•°å­˜åœ¨å‰¯ä½œç”¨ï¼Œé‚£ä¹ˆé€šå¸¸æ˜¯ç”±äºå­˜åœ¨æŸäº›ç»´æŠ¤äº†ç³»ç»ŸçŠ¶æ€çš„å˜é‡è€Œå¯¼è‡´çš„ã€‚æ¯æ¬¡å‡½æ•°è°ƒç”¨æ—¶ï¼Œå³ä½¿è¾“å…¥ç›¸åŒï¼Œä½†ç³»ç»ŸçŠ¶æ€çš„å·®å¼‚ä¼šå¯¼è‡´å‡½æ•°è¾“å‡ºç»“æœä¸åŒï¼šè¿™æ ·çš„å‡½æ•°è¢«ç§°ä¸ºå…·æœ‰å‰¯ä½œç”¨çš„å‡½æ•°ã€‚*

**å…ƒå‡½æ•°ä¼šåœ¨ç¼–è¯‘å™¨è¢«è°ƒç”¨ä¸æ‰§è¡Œ**ï¼Œåœ¨ç¼–è¯‘é˜¶æ®µï¼Œç¼–è¯‘å™¨åªèƒ½æ„é€ å¸¸é‡ä½œä¸ºå…¶ä¸­é—´ç»“æœï¼Œæ— æ³•æ„é€ å¹¶ç»´æŠ¤å¯ä»¥è®°å½•ç³»ç»ŸçŠ¶æ€å¹¶éšä¹‹æ”¹å˜çš„é‡ï¼Œå› æ­¤ç¼–è¯‘å™¨å¯ä»¥ä½¿ç”¨çš„å‡½æ•°ï¼ˆå³å…ƒå‡½æ•°ï¼‰åªèƒ½æ˜¯æ— å‰¯ä½œç”¨çš„å‡½æ•°

```c++
constexpr int fun(int a){
    return a+1;
}
```

å…ƒå‡½æ•°çš„ç±»å‹ï¼š

+ æ•°å€¼å…ƒå‡½æ•°
+ ç±»å‹å…ƒå‡½æ•°ï¼šä»¥ç±»å‹ä½œä¸ºè¾“å…¥ï¼ˆæˆ–è¾“å‡ºï¼‰çš„å…ƒå‡½æ•°

> å…ƒå‡½æ•°å¾—å®šä¹‰
>
> ğŸš©å…·æœ‰è¾“å…¥ï¼ˆTï¼‰ï¼Œè¾“å‡º
>
> ğŸš©å…·æœ‰æ˜ç¡®å®šä¹‰æ˜ å°„è§„åˆ™ï¼Œæ— å‰¯ä½œç”¨ï¼Œå¯ä»¥åœ¨ç¼–è¯‘å™¨è¢«è°ƒç”¨



### type_traits

å…ƒå‡½æ•°åº“ï¼Œè¿™ä¸ªåº“å®ç°ç±»å‹å˜åŒ–ã€ç±»å‹æ¯”è¾ƒä¸åˆ¤æ–­ç­‰åŠŸèƒ½

> *C++æ ‡å‡†æ¨¡æ¿åº“*

å…ƒå‡½æ•°ä¸å®çš„åŒºåˆ«ï¼š

- å®æ˜¯ç”±é¢„å¤„ç†å™¨è€Œéç¼–è¯‘å™¨æ‰€è§£æçš„



**å…ƒå‡½æ•°å¯ä»¥æ“ä½œç±»å‹ä¸æ•°å€¼ï¼›å¯¹äºå…ƒå‡½æ•°æ¥è¯´ï¼Œç±»å‹ä¸æ•°å€¼å¹¶æ²¡æœ‰æœ¬è´¨ä¸Šçš„åŒºåˆ«ï¼Œå®ƒä»¬éƒ½å¯ä»¥è§†ä¸ºä¸€ç§â€œæ•°æ®â€ï¼Œå¯ä»¥ä½œä¸ºå…ƒå‡½æ•°çš„è¾“å…¥ä¸è¾“å‡º**

å…ƒå‡½æ•°å¯ä»¥æ“ä½œçš„æ•°æ®ï¼š

- [ ] æ•°å€¼
- [ ] ç±»å‹
- [ ] æ¨¡æ¿

```c++
#include <cstdio>
#include <type_traits>
template <template <typename> class T1, typename T2>
struct Fun_ {
    using type = typename T1<T2>::type;
};

template<template<typename> class T1,typename T2>
using Fun = typename Fun_<T1,T2>::type;

int main()
{
      Fun<std::remove_reference, int&> h = 3;
}
```

ä»ç¼–è¯‘å™¨çš„è§’åº¦çœ‹

```c++
#include <cstdio>
#include <type_traits>
template <template <typename> class T1, typename T2>
struct Fun_ {
    using type = typename T1<T2>::type;
};

/* First instantiated from: insights.cpp:9 */
#ifdef INSIGHTS_USE_TEMPLATE
template<>
struct Fun_<std::remove_reference, int &>
{
  using type = typename remove_reference<int &>::type;
};

#endif


template<template<typename> class T1,typename T2>
using Fun = typename Fun_<T1,T2>::type;

int main()
{
  Fun<std::remove_reference, int &> h = 3;
  return 0;
}
```



> ã€ŠC++æ¨¡æ¿å…ƒç¼–ç¨‹ã€‹
>
> **æ¨¡æ¿å…ƒç¼–ç¨‹åº“MPLï¼ˆBoost C++ template Meta-Programming libraryï¼‰**

### å®¹å™¨æ¨¡æ¿

å˜é•¿å‚æ•°æ¨¡æ¿

```c++
template<int ... Vals> struct IntContainer;
template<typename ...Types> stuct TypeContainer;
template<template<type > class ...T> strcut TemplateConts;
```

è¿™äº›éƒ½æ˜¯å£°æ˜å¹¶éå®šä¹‰ï¼Œè¿™æ˜¯å…ƒç¼–ç¨‹çš„ä¸€ä¸ªç‰¹ç‚¹ï¼Œéœ€è¦å®šä¹‰å—ï¼Ÿä¸éœ€è¦ï¼Œå› ä¸ºå£°æ˜ä¸­åŒ…å«äº†ç¼–è¯‘å™¨æ‰€éœ€è¦ä½¿ç”¨çš„å…¨éƒ¨ä¿¡æ¯

å…ƒç¼–ç¨‹ä¸­çš„ä¸€ä¸ªæƒ¯ç”¨æ³•ï¼š**ä»…åœ¨å¿…è¦æ—¶æ‰å¼•å…¥å®šä¹‰ï¼Œå…¶ä»–çš„æ—¶å€™ç›´æ¥ä½¿ç”¨å£°æ˜å³å¯**



## ç¼–è¯‘å™¨ä¸­çš„é¡ºåºã€åˆ†æ”¯ä¸å¾ªç¯

**æ„æˆæ•´ä¸ªå…ƒç¼–ç¨‹ä½“ç³»çš„æ ¸å¿ƒ**



### é¡ºåº

*åœ¨ç¼–è¯‘æœŸï¼Œç¼–è¯‘æœŸä¼šæ‰«æä¸¤éç»“æ„ä½“ä¸­çš„ä»£ç *



### åˆ†æ”¯



å®ç°åˆ†æ”¯çš„æ–¹å¼ï¼š

+ ä½¿ç”¨æ¨¡æ¿çš„ç‰¹åŒ–æˆ–è€…éƒ¨åˆ†ç‰¹åŒ–æ¥å®ç°åˆ†æ”¯

  + æ³¨æ„ï¼šåœ¨éå®Œæˆç‰¹åŒ–çš„ç±»æ¨¡æ¿ä¸­å¼•å…¥å®Œå…¨ç‰¹åŒ–çš„åˆ†æ”¯ä»£ç æ˜¯éæ³•çš„
  + 

+ ä½¿ç”¨std::conditional

  + ```c++
    #include <cstdio>
    #include <type_traits>
    namespace ltd{
    template<bool B,typename T, typename F>
    	struct conditional{
    		using type = T;
    	};
    template<typename T, typename F>
        struct conditional<false,T,F>{
        	using type = F;
        };
    template<bool B,typename T, typename F>
    using conditona_t = typename conditional<B,T,F>::type;
    }
    
    
    int main()
    {
          ltd::conditional<true,int,float>::type x = 3;
          ltd::conditional<false,int ,float>::type y = 1.0f;
    }
    ```

ä½¿ç”¨ç¼–è¯‘å™¨è§’åº¦çœ‹

```c++
#include <cstdio>
#include <type_traits>
namespace ltd
{
  template<bool B, typename T, typename F>
  struct conditional
  {
    using type = T;
  };
  
  /* First instantiated from: insights.cpp:19 */
  #ifdef INSIGHTS_USE_TEMPLATE
  template<>
  struct conditional<1, int, float>
  {
    using type = int;
  };
  
  #endif
  /* First instantiated from: insights.cpp:20 */
  #ifdef INSIGHTS_USE_TEMPLATE
  template<>
  struct conditional<0, int, float>
  {
    using type = float;
  };
  
  #endif
  template<typename T, typename F>
  struct conditional<false, T, F>
  {
    using type = F;
  };
  
  template<bool B, typename T, typename F>
  using conditona_t = typename conditional<B, T, F>::type;
  
}


int main()
{
  ltd::conditional<true, int, float>::type x = 3;
  ltd::conditional<false, int, float>::type y = 1.0F;
  return 0;
}
```

- ä½¿ç”¨ï¼ˆéƒ¨åˆ†ï¼‰ç‰¹åŒ–å®ç°åˆ†æ”¯
  - **åœ¨éå®Œå…¨ç‰¹åŒ–çš„ç±»æ¨¡æ¿ä¸­å¼•å…¥å®Œå…¨ç‰¹åŒ–çš„åˆ†æ”¯ä»£ç æ˜¯éæ³•çš„**



+ std::enable_ifæ¥å®ç°åˆ†æ”¯

> c++ä¸­æœ‰ä¸€ä¸ªç‰¹æ€§SFINAEï¼ŒåŒ¹é…å¤±è´¥å¹¶éé”™è¯¯

ç”¨ä½œé‡è½½çš„è¡¥å……ï¼Œè‹¥æ˜¯æ— æ³•é€šè¿‡å‚æ•°ç±»å‹åŠ ä»¥åŒºåˆ†ï¼Œæ­¤æ—¶å¯ä»¥é€šè¿‡enable_ifå°±èƒ½ä¸€å®šç¨‹åº¦ä¸Šè§£å†³ç›¸åº”çš„é‡è½½é—®é¢˜

```c++
#include <cstdio>
template<bool B,typename T = void>
struct enable_if{};

template<class T>
struct enable_if<true,T>{
  using type = T;
};

template<bool B, class T = void>
using enable_if_t = typename enable_if<B,T>::type;


template<bool check, enable_if_t<check>* = nullptr>
auto fun(){
  return (int)0;
}
  
template<bool check, enable_if_t<!check>* = nullptr>
auto fun(){
  return (double)0;
}

int main()
{
  fun<true>();
  fun<false>();
}
```

ä»ç¼–è¯‘å™¨çš„è§’åº¦çœ‹å¾…

```c++
#include <cstdio>
template<bool B,typename T = void>
struct enable_if{};

/* First instantiated from: insights.cpp:11 */
#ifdef INSIGHTS_USE_TEMPLATE
template<>
struct enable_if<false, void>
{
};

#endif


/* First instantiated from: insights.cpp:11 */
#ifdef INSIGHTS_USE_TEMPLATE
template<>
struct enable_if<true, void>
{
  using type = void;
};

#endif


template<class T>
struct enable_if<true, T>
{
  using type = T;
};



template<bool B, class T = void>
using enable_if_t = typename enable_if<B,T>::type;


template<bool check, enable_if_t<check>* = nullptr>
auto fun(){
  return (int)0;
}

#ifdef INSIGHTS_USE_TEMPLATE
template<>
int fun<true, void *>()
{
  return static_cast<int>(0);
}
#endif

  
template<bool check, enable_if_t<!check>* = nullptr>
auto fun(){
  return (double)0;
}

#ifdef INSIGHTS_USE_TEMPLATE
template<>
double fun<false, void *>()
{
  return static_cast<double>(0);
}
#endif


int main()
{
  fun<true>();
  fun<false>();
  return 0;
}
```





- ä½¿ç”¨if constexpr



### å¾ªç¯



ä¸€èˆ¬æ¥è¯´ï¼Œä¸ä¼šç”¨while forè¿™æ ·çš„è¯­å¥æ¥ç»„ç»‡å…ƒå‡½æ•°ä¸­çš„å¾ªç¯ä»£ç ï¼Œå› ä¸ºè¿™äº›ä»£ç æ“ä½œçš„æ˜¯å˜é‡ï¼Œä¸ºäº†èƒ½å¤Ÿæœ‰æ•ˆçš„æ“ä½œå…ƒæ•°æ®ï¼Œä¼šä½¿ç”¨é€’å½’çš„å½¢å¼æ¥å®ç°å¾ªç¯ã€‚

```c++
#include <cstdio>

template< size_t Input>
constexpr size_t OnesCount = (Input % 2) + OnesCount<(Input /2)>;
template<> constexpr size_t OnesCount<0> = 0;
int main()
{
  constexpr size_t res = OnesCount<45>;
}
```



```c++
#include <cstdio>
template<size_t Input>
constexpr const size_t OnesCount = (Input % 2) + OnesCount<(Input / 2)>;

template<>
constexpr const size_t OnesCount<45> = (45UL % 2) + OnesCount<(45UL / 2)>;
template<>
constexpr const size_t OnesCount<22> = (22UL % 2) + OnesCount<(22UL / 2)>;
template<>
constexpr const size_t OnesCount<11> = (11UL % 2) + OnesCount<(11UL / 2)>;
template<>
constexpr const size_t OnesCount<5> = (5UL % 2) + OnesCount<(5UL / 2)>;
template<>
constexpr const size_t OnesCount<2> = (2UL % 2) + OnesCount<(2UL / 2)>;
template<>
constexpr const size_t OnesCount<1> = (1UL % 2) + OnesCount<(1UL / 2)>;
<> constexpr size_t OnesCount<0> = 0;
int main()
{
  constexpr const size_t res = OnesCount<45>;
  return 0;
}
```



**å®ä¾‹åŒ–çˆ†ç‚¸å’Œç¼–è¯‘å´©æºƒ**ï¼šè¿™ä¸ªé—®é¢˜è¦è¶³å¤Ÿçš„é‡è§†

```c++
template <size_t ID>
struct imp{
     constexpr static size_t value = ID + imp<ID-1>::value;
};
template<>
struct imp<0>{
	constexpr static size_t value = 0;
}
template<size_t A>
struct Wrap_{
    template <size_t ID>
    constexpr static size_t value=imp<A+ID>::value;
}
```

#### å¥‡ç‰¹çš„é€’å½’æ¨¡æ¿å¼

|                      |                                                     |
| -------------------- | --------------------------------------------------- |
| åŸºæœ¬å˜æ¢             | è¾“å…¥ä¸€ä¸ªç±»å‹ï¼Œè¿”å›ç›¸åº”çš„æŒ‡é’ˆç±»å‹---ã€‹å…ƒå‡½æ•°æ˜¯æœ€ä½çº§ |
| åŒ…å«é¡ºåºã€åˆ†æ”¯ä¸å¾ªç¯ |                                                     |
| å¥‡ç‰¹çš„é€’å½’æ¨¡æ¿å¼     | é«˜çº§ç”¨æ³•                                            |

*åœ¨eigenåº“ä¸­ä¹Ÿæœ‰ä½¿ç”¨*

å¥‡ç‰¹çš„é€’å½’æ¨¡æ¿å¼ï¼ˆCRTPï¼‰æ˜¯ä¸€ç§æ´¾ç”Ÿç±»çš„å£°æ˜æ–¹å¼ï¼Œå…ƒç¼–ç¨‹æ¶‰åŠçš„å‡½æ•°å¤§éƒ¨åˆ†ä¸æ¨¡æ¿ç›¸å…³ï¼Œæˆ–è€…å¾€å¾€æ˜¯ç±»ä¸­çš„é™æ€å‡½æ•°ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¦‚æœ**è¦å®ç°ç±»ä¼¼è¿è¡ŒæœŸçš„å¤šæ€ç‰¹æ€§**ï¼Œå°±å¯ä»¥è€ƒè™‘ä½¿ç”¨CRTP

**å®ç°ç±»ä¼¼è™šå‡½æ•°çš„åŠŸèƒ½**

```c++
#include <iostream>

template<typename D>
struct Base{
  template <typename TI>
    void Fun(const TI &input){
      D* ptr = static_cast<D*>(this);
      ptr->Imp(input);
  }
};
struct Derive:public Base<Derive>{
  
    template<typename TI>
    void Imp(const TI& input){
        std::cout << input << std::endl;
    }
};

int main(){
    Derive d;
    d.Fun("Implementation from derive class");
}
```



```c++
#include <iostream>

template<typename D>
struct Base{
  template <typename TI>
    void Fun(const TI &input){
      D* ptr = static_cast<D*>(this);
      ptr->Imp(input);
  }
};

/* First instantiated from: insights.cpp:11 */
#ifdef INSIGHTS_USE_TEMPLATE
template<>
struct Base<Derive>
{
  template<typename TI>
  inline void Fun(const TI & input);
  
  /* First instantiated from: insights.cpp:21 */
  #ifdef INSIGHTS_USE_TEMPLATE
  template<>
  inline void Fun<char [33]>(char const (&input)[33])
  {
    Derive * ptr = static_cast<Derive *>(this);
    ptr->Imp<char [33]>(input);
  }
  #endif
  
  // inline constexpr Base() noexcept = default;
};

#endif

struct Derive : public Base<Derive>
{
  template<typename TI>
  inline void Imp(const TI & input)
  {
    (std::cout << input) << std::endl;
  }
  
  /* First instantiated from: insights.cpp:8 */
  #ifdef INSIGHTS_USE_TEMPLATE
  template<>
  inline void Imp<char [33]>(char const (&input)[33])
  {
    std::operator<<(std::cout, input).operator<<(std::endl);
  }
  #endif
  
  // inline constexpr Derive() noexcept = default;
};



int main()
{
  Derive d = Derive();
  static_cast<Base<Derive>&>(d).Fun<char [33]>("Implementation from derive class");
  return 0;
}
```





## å¼‚ç±»è¯å…¸ä¸policyæ¨¡æ¿



### å…·åå‚æ•°

ä½¿ç”¨å…·åå‚æ•°è¿›è¡Œå‡½æ•°è°ƒç”¨ï¼Œå¯ä»¥ä¸€å®šç¨‹åº¦ä¸Šç¯å¢ƒï¼Œä¼ å…¥å‚æ•°çš„é”™è¯¯



#### å¼‚ç±»è¯å…¸çš„å®ç°



ä¸¤ä¸ªæ¦‚å¿µï¼štraitå’Œpolicyï¼Œ traitç”¨äºæè¿°ç‰¹æ€§ï¼Œpolicyç”¨äºæè¿°è¡Œä¸º

> å‚åŠ C++ templatesä¸­æ–‡ç‰ˆ





#### æ”¯é…ä¸è™šç»§æ‰¿

```c++
struct A{
	void fun();
}
struct B :A {
  void fun();
};
struct C:B{
	void wrapper(){
		fun();
	}
}
//è‹¥æ˜¯è°ƒç”¨wrapper ï¼Œä¼šæ‰§è¡Œå“ªä¸ªfun
```



æ ¹æ®C++ä¸­çš„ç»§æ‰¿è§„åˆ™ï¼Œè‹¥æ˜¯Cä¸­æ²¡æœ‰funå®šä¹‰ï¼Œåˆ™ä¼šé¡ºç€ç»§æ‰¿å…³ç³»ï¼Œå¾€ä¸Šå¯»æ‰¾ï¼Œå³B

åœ¨æœç´¢çš„è¿‡ç¨‹ä¸­ï¼Œç¼–è¯‘å™¨ä¼šé€‰æ‹©å…·æœ‰æ”¯é…åœ°ä½çš„å‡½æ•°

åœ¨å¤šé‡ç»§æ‰¿æƒ…å†µä¸‹ï¼Œå…·æœ‰è™šç»§æ‰¿æ‰ä¼šæœ‰æ•ˆï¼Œå¦åˆ™ï¼Œç¼–è¯‘ä¼šæŠ¥å‘Šå‡½æ•°è§£ææœ‰æ­§ä¹‰



#### metaNN

è‡ªåº•å‘ä¸Šåˆ’åˆ†ä¸º4ä¸ªå±‚æ¬¡ï¼š

- [ ] æ•°æ®
- [ ] è¿ç®—
- [ ] å±‚
- [ ] æ±‚å€¼

