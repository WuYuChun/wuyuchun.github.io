---
layout: post

title:  "cuda的编译"

date:   2020-05-09 14:29

excerpt:

tag:

- GPU
---


[TOC]



# 简介

这里主要介绍nvcc编译器的工作



# 介绍

- [ ] cuda的源文件是如何编译成可执行文件的



# 编译阶段



## NVCC阶段

每当主机程序启动设备代码时，CUDA运行时系统就会对嵌入式的fatbinary进行检查，以获得适合当前GPU的fatbinary映像。

![](/images/posts/2020-05-15-09-32-19-nvcc-build.png)

## 例子

这个例子讲解cuda如何编译到可执行文件中

1. 编写一个包含kernel以及kernel调用的.cu文件，输入一下命令

   ```shell
   nvcc -cuda p46.cu --keep
   ```

   或者下面的命令：

   ```shell
   nvcc --compile-only p46.cu --keep --dryrun --verbose
   ```

   输出的结果：

   ```shell
   #$ _SPACE_= 
   #$ _CUDART_=cudart
   #$ _HERE_=/usr/local/cuda/bin
   #$ _THERE_=/usr/local/cuda/bin
   #$ _TARGET_SIZE_=
   #$ _TARGET_DIR_=
   #$ _TARGET_SIZE_=64
   #$ TOP=/usr/local/cuda/bin/..
   #$ NVVMIR_LIBRARY_DIR=/usr/local/cuda/bin/../nvvm/libdevice
   #$ LD_LIBRARY_PATH=/usr/local/cuda/bin/../lib:/usr/local/cuda/lib64:
   #$ PATH=/usr/local/cuda/bin/../nvvm/bin:/usr/local/cuda/bin:/usr/local/cuda/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
   #$ INCLUDES="-I/usr/local/cuda/bin/..//include"  
   #$ LIBRARIES=  "-L/usr/local/cuda/bin/..//lib64/stubs" "-L/usr/local/cuda/bin/..//lib64"
   #$ CUDAFE_FLAGS=
   #$ PTXAS_FLAGS=
   #$ gcc -std=c++14 -D__CUDA_ARCH__=300 -E -x c++  -DCUDA_DOUBLE_MATH_FUNCTIONS -D__CUDACC__ -D__NVCC__  "-I/usr/local/cuda/bin/..//include"    -D__CUDACC_VER_MAJOR__=10 -D__CUDACC_VER_MINOR__=0 -D__CUDACC_VER_BUILD__=130 -include "cuda_runtime.h" -m64 "p46.cu" > "p46.cpp1.ii" 
   #$ cicc --c++14 --gnu_version=70500 --allow_managed   -arch compute_30 -m64 -ftz=0 -prec_div=1 -prec_sqrt=1 -fmad=1 --include_file_name "p46.fatbin.c" -tused -nvvmir-library "/usr/local/cuda/bin/../nvvm/libdevice/libdevice.10.bc" --gen_module_id_file --module_id_file_name "p46.module_id" --orig_src_file_name "p46.cu" --gen_c_file_name "p46.cudafe1.c" --stub_file_name "p46.cudafe1.stub.c" --gen_device_file_name "p46.cudafe1.gpu"  "p46.cpp1.ii" -o "p46.ptx"
   #$ ptxas -arch=sm_30 -m64  "p46.ptx"  -o "p46.sm_30.cubin" 
   #$ fatbinary --create="p46.fatbin" -64 "--image=profile=sm_30,file=p46.sm_30.cubin" "--image=profile=compute_30,file=p46.ptx" --embedded-fatbin="p46.fatbin.c" --cuda
   #$ gcc -std=c++14 -E -x c++ -D__CUDACC__ -D__NVCC__  "-I/usr/local/cuda/bin/..//include"    -D__CUDACC_VER_MAJOR__=10 -D__CUDACC_VER_MINOR__=0 -D__CUDACC_VER_BUILD__=130 -include "cuda_runtime.h" -m64 "p46.cu" > "p46.cpp4.ii" 
   #$ cudafe++ --c++14 --gnu_version=70500 --allow_managed  --m64 --parse_templates --gen_c_file_name "p46.cudafe1.cpp" --stub_file_name "p46.cudafe1.stub.c" --module_id_file_name "p46.module_id" "p46.cpp4.ii" 
   #$ gcc -std=c++14 -D__CUDA_ARCH__=300 -c -x c++  -DCUDA_DOUBLE_MATH_FUNCTIONS "-I/usr/local/cuda/bin/..//include"   -m64 -o "p46.o" "p46.cudafe1.cpp" 
   ```

   

   其中keep表示保留中间结果。

   在相应的目录下有如下的结果：

   ![编译结果](/images/posts/2020-05-15-09-52-27-build_result.png)

   

2. 拆解一下上面终端的输出结果：

   环境变量的什么就不说了

   1）p46.cu-->p46.cpp1.ii

   ```shell
   #$ gcc -std=c++14 -D__CUDA_ARCH__=300 -E -x c++  -DCUDA_DOUBLE_MATH_FUNCTIONS -D__CUDACC__ -D__NVCC__  "-I/usr/local/cuda/bin/..//include"    -D__CUDACC_VER_MAJOR__=10 -D__CUDACC_VER_MINOR__=0 -D__CUDACC_VER_BUILD__=130 -include "cuda_runtime.h" -m64 "p46.cu" > "p46.cpp1.ii" 
   ```

   2）p46.cpp1.ii--->p46.ptx

   ```shell
   #$ cicc --c++14 --gnu_version=70500 --allow_managed   -arch compute_30 -m64 -ftz=0 -prec_div=1 -prec_sqrt=1 -fmad=1 --include_file_name "p46.fatbin.c" -tused -nvvmir-library "/usr/local/cuda/bin/../nvvm/libdevice/libdevice.10.bc" --gen_module_id_file --module_id_file_name "p46.module_id" --orig_src_file_name "p46.cu" --gen_c_file_name "p46.cudafe1.c" --stub_file_name "p46.cudafe1.stub.c" --gen_device_file_name "p46.cudafe1.gpu"  "p46.cpp1.ii" -o "p46.ptx"
   ```

   3）ptx-->cubin

   ```shell
   #$ ptxas -arch=sm_30 -m64  "p46.ptx"  -o "p46.sm_30.cubin" 
   ```

   4）cubin-->fatbin

   ```shell
   #$ fatbinary --create="p46.fatbin" -64 "--image=profile=sm_30,file=p46.sm_30.cubin" "--image=profile=compute_30,file=p46.ptx" --embedded-fatbin="p46.fatbin.c" --cuda
   ```

   5）cpp-->cpp4.ii

   ```shell
   #$ gcc -std=c++14 -E -x c++ -D__CUDACC__ -D__NVCC__  "-I/usr/local/cuda/bin/..//include"    -D__CUDACC_VER_MAJOR__=10 -D__CUDACC_VER_MINOR__=0 -D__CUDACC_VER_BUILD__=130 -include "cuda_runtime.h" -m64 "p46.cu" > "p46.cpp4.ii"
   ```

   6）

   ```shell
   #$ cudafe++ --c++14 --gnu_version=70500 --allow_managed  --m64 --parse_templates --gen_c_file_name "p46.cudafe1.cpp" --stub_file_name "p46.cudafe1.stub.c" --module_id_file_name "p46.module_id" "p46.cpp4.ii" 
   ```

   7）

   ```shell
   gcc -std=c++14 -D__CUDA_ARCH__=300 -c -x c++  -DCUDA_DOUBLE_MATH_FUNCTIONS "-I/usr/local/cuda/bin/..//include"   -m64 -o "p46.o" "p46.cudafe1.cpp" 
   ```

   

3. 查看p46.ptx以及p46.sm_30.cubin

```c++
//
// Generated by NVIDIA NVVM Compiler
//
// Compiler Build ID: CL-24817639
// Cuda compilation tools, release 10.0, V10.0.130
// Based on LLVM 3.4svn
//

.version 6.3
.target sm_30
.address_size 64

	// .globl	_Z3addiiPi

.visible .entry _Z3addiiPi(
	.param .u32 _Z3addiiPi_param_0,
	.param .u32 _Z3addiiPi_param_1,
	.param .u64 _Z3addiiPi_param_2
)
{
	.reg .b32 	%r<4>;
	.reg .b64 	%rd<3>;


	ld.param.u32 	%r1, [_Z3addiiPi_param_0];
	ld.param.u32 	%r2, [_Z3addiiPi_param_1];
	ld.param.u64 	%rd1, [_Z3addiiPi_param_2];
	cvta.to.global.u64 	%rd2, %rd1;
	add.s32 	%r3, %r2, %r1;
	st.global.u32 	[%rd2], %r3;
	ret;
}
```

- [ ] **cubin** ， **ptx** 是如何组织到 **exe** 中，又是如何被加载到驱动中去的



# 编译选项

- [ ] 这里有很多的编译选项，可以显示很多的有用信息





# GPU 汇编

![](/images/posts/2020-05-16-09-49-40-virtual_and_real.png)



# 通过编译查看kernel的资源使用

命令如下：

```shell
nvcc --resource-usage p46.cu
```

结果如下：

```shell
ptxas info    : 0 bytes gmem
ptxas info    : Compiling entry function '_Z3addiiPi' for 'sm_30'
ptxas info    : Function properties for _Z3addiiPi
    0 bytes stack frame, 0 bytes spill stores, 0 bytes spill loads
ptxas info    : Used 5 registers, 336 bytes cmem[0]
```

As shown in the above example, the amounts of statically allocated global memory (gmem) and constant memory in bank 0 (cmem) are listed.

stack fram是每个线程的堆栈使用量。溢出存储和加载表示在堆栈内存上完成的存储和加载，这些存储和加载用于存储不能分配给物理寄存器的变量。
