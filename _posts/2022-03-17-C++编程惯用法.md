# C++编程惯用法



## 抽象

每一个编程问题的解决方案都可以划分为两部分：一个抽象模型，以及 该模型的实现

设计抽象模型和设计实现方案应该是两个独立的行为

用一句话来描述该对象是用来干什么的（注意：不是“是什么”）

在保证实用性的前提下，尽可能地将该模型最小化以使其将尽可能通用化

即便是定义很好的抽象模型，最终还是被别人以一种设计者从来都没有考虑过的方式使用

边界存在的地方总是不能满足抽象模型的假设基础

数据抽象：对象的物理结构没有必要反映出来它的抽象结构



## 类



缺省的复制构造函数和赋值操作行为是否符合预期

- 对于包含指针的类要另眼相待，如果被指向的对象是属于该产生的对象，那么缺省复制构造函数有可能出错的，因为它只是简单的复制指针，不是指针所指向的对象
- 缺省情况下，在构造函数的函数体被执行前，对象中的所有成员都已经被它们的缺省构造函数所初始化

操作符重载

- 成员
  - 最好将一元操作符实现为成员函数
  - []、=、()、->、必须是成员操作符函数
  - +=、-=、/=等等
- 非成员
  - 其他的二元操作符

类提供两种接口

- 对外：面向用户
- 对内：面向它的派生类

## 句柄

实现用尺寸大小固定的对象来表示尺寸大小不定的值

实现中用运行时绑定，而不是编译时绑定的方式

对于实现的改变通常只会引起一次重新链接，而不是重新编译

## 继承

新类（派生类）描述的对象集是基类描述的对象集的一个子集

任何试图在派生类中对操作进行限制的行为通常都意味着继承架构设计上的失误

在派生类中需要重写基类中的虚函数，但是又不希望对基类的使用暴露于公用接口中。如果被重写的函数是析构函数，最简单的做法就是使用私有继承

那些声明（或继承）了纯虚函数的类就是抽象基类，一个继承（而没有重写）了纯虚函数的类同样也是一个抽象类

以下没有从基类中被继承：

- 构造函数（包括复制构造函数）
- 析构函数
- 赋值操作符
- 被隐藏的成员函数

只有在构造函数和析构函数中调用虚函数才会导致特殊的行为出现

## 多重继承

多重继承描述的是对象间的交集，而并不是合集

虚基类：对象中所有的虚基类的实例都是被共享的



## 考虑继承的设计

是不是所有的类在设计时都必须考虑到继承呢？

- 正确性
- 性能
  - 虚函数和虚基类只会带来适量的性能损耗

## 模板

模板和宏的区别

实例化的动作就是用这些类型参数去替换模板声明中的模板参数

然后编译器会编译该实例得到它的目标文件并把该文件传递给链接器去使用

编译器如何缓存模板的实例保持密切关注

- 假设在一个大型项目中使用超过100个模板实例，如果每一次链接都对它们进行重编译的化，编译的开销会很大

模板函数

- 对于模板参数来说，不存在隐式的类型转换
- 使用模板函数很容易得到大量冗余的代码
- 模板函数最适合的地方就是那些小函数
  - 因为小函数不会带来太多的空间开销

当用于处理对象的逻辑和对象本身无关的时候，最好使用模板



## 异常

C四种处理异常情况的方法：

- 忽略它们

- 检测到异常直接退出程序而不提供恢复机制

- 设置全局错误代码或者让函数返回错误代码

- 使用setjmp和longjmp：

  [使用方法]: https://www.cnblogs.com/hazir/p/c_setjmp_longjmp.html

c++程序不适用setjmp和longjmp，因为longjmp在对堆栈进行展开时不会销毁处于栈中的自动对象，造成程序混乱

异常应该只被用来处理异常的状况，不应该被用于程序的正常控制流

在伴随着异常被抛出后的栈展开过程中，任何栈上的自动对象都将被销毁，然而，这却无法保证 所有的资源都会被释放

理解异常：

- 是谁或者什么导致了这个问题的产生
- 谁或者什么将处理它，哪个部分负责检测它们 
- 每一个异常，都像其他的特性一样，都会程序增加复杂性，而复杂性就是一种潜在的代价。

## 重用

向外声称某些事件永远不会发生，是一种天真的做法

内存管理：

- [ ] 核心思想：让计算机以某种方式来记录被分配的内存，从而程序员就不需要时刻记着去删除它们
- [ ] 使用自动对象处理内存的释放只适合于同一个函数中的内存分配和释放
- [ ] 使用计数器的智能指针
- [ ] 通过记录所有的指针和对象来实现的垃圾收集机制
- [ ] arena
- [ ] placement语法
- [ ] 在析构函数中进行对成员变量的的无意义填充，能发现内存使用bug

assert的副作用：当定义NDEBUG时，断言会不执行，而断言里面可能进行释放资源操作，要小心这种情况

管理外部资源：exit（）会导致静态对象被摧毁，但它不会去摧毁那些自动对象

性能：

- 程序的正确性比它的速度更重要
- 不要去猜想，而是度量







































