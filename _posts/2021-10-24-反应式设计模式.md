# 反应式设计模式



## 为什么需要反应式



![](/images/posts/2021-10-24-反应式设计模式01.png)

- 应对负载
- 应对失败
- 让系统即时响应



利用并行性

- 通过并行化降低延迟
- 并行执行必须与异步的，面向任务的结果聚合配合使用

并行执行的限制

- 阿姆达尔定律

对失败做出的反应：

- 软件总有故障的时候
- 硬件总有故障的时候
- 人类总有失误的时候
- 超时也是一种失败

问题不在于是否会发生失败，而在于失败发生的时间点和频率。



函数式编程：多核CPU的到来为并行化开辟了新的机会，但在这样的环境中，具有副作用的命令式编程结构成分可能难以为继。一个C++开发者已经跳着在单线程的应用程序中自行管理内存开销，而在多核世界，他们现必须管理跨多个线程的内存，还得弄清楚可以在什么时刻访问共享的内存。

函数式编程的本质：**洞察到程序实际上可以按照纯粹的数学函数来编写，也就是说 每次给这些函数传递相同的输入时，他们将总会返回相同的值，并不会产生副作用**

核心概念：

- 不可变性
- 引用透明性
- 副作用
- 函数作为一等公民

争用是在多核心CPU上运行的代码最大的性能杀手。

反应式应用程序的性能权衡如下，有三种特质：

- 高吞吐量
- 低延迟
- 资源占用小

> Future是一个只读的句柄，提供可能在将来某个时间点就绪的值或者是失败的结果，Promise是对应单词写入句柄，以允许提供值。

**Actor模型：一种并发计算模型，其中的所有通信，通过发送方的消息传递机制和接收方的信箱队列，在被称为Actor的实体之间发生**

事件是建立消息传递的基石，事实上，一个特定条件的触发（事件本身）捆绑了上下文信息-如某人在某时某地做了某事-并且被生产者以消息的形式传送。

数据生产者和数据消费者的关联互动有两种模型：

- 基于事件：事件生产者是可寻址的，以便回调可以在它们那里注册
- 基于消息：消费者是可寻址的，如何才可以被赋予处理特定消息的职责

> 如果你发现某一个组件难以详细说明，这意味着它的功能要么需要一个复杂描述，那么过于含糊，需要后退一步甚至几步，以改正早期遗留的错误。



## 设计模式



### 容错以及恢复模式



#### 简单组件模式

**一个组件应该只做一件事情，并且完整做完**



#### 错误内核模式

**在监督层级中，将重要的应用程序状态或功能存留在根部附近，而将具有风险操作委托给叶子节点**



#### 放任崩溃模式

**对于内部失败处理，优先选择完整重启组件**



#### 断路器模式

**在失败时间延长时，通过断开与用户之间的链接来保护服务**



### 复制模式



#### 主动-被动复制模式

保持服务的多个副本运行在不同的位置，但在任何时刻，只接受对于其中一个位置的状态修改。



#### 多主复制模式

在不同位置上保持服务的多个副本，每处都可接受修改，并将所有的修改在各个副本之间传播

#### 主动-主动复制模式





### 资源管理模式



#### 资源封装模式



#### 资源借贷模式



#### 复杂命令模式



#### 资源池模式





#### 托管阻塞模式



### 消息流模式



#### 请求-响应模式



#### 消息自包含模式



#### 询问模式





#### 转发流模式





#### 聚合器模式





#### 事务序列模式





#### 业务握手协议





### 流量控制模式



#### 拉取模式



#### 托管队列模式





#### 丢弃模式





#### 限流模式





### 状态管理和持久化模式





#### 领域对象模式





#### 分片模式





#### 事件溯源模式



#### 事件流模式



