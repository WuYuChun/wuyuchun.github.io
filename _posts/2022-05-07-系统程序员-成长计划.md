## 前言

 > 草莓酱定律和果酱定律：面积涂得越大, 酱就越薄.它说明如果被过分引申,任何深刻的寓意都会被减弱；只要还有颗粒, 草莓酱就永远都不会被涂抹得过薄

开发两大难点：
+ 控制软件的复杂度
  + 战胜复杂段的两个方面
    + 防止复杂度增长
      + 抽象
    + 降低复杂度
      + 分而治之
+ 隔离变化

## 谁动了你的隐私

> 侯捷先生：学从难处学，用从易处用

全局变量始终都会占用内存空间，共享库的全局变量是按页分配的，哪怕只有一个字节的全局变量也占用一个页，这样一来就会造成不必要的内存空间浪费

在软件中，对象是一个运行时概念，它只存在于运行环境中。类是一个设计时概念，它只存在于代码中，运行时并不存在某个类和某个类之间的交互

```
void func_test(void * ctx){
    Dclass *p = (Dclass *)ctx;
    ...
}
```
*ctx表示函数的上下文

在程序中，数据存放的位置主要由以下几个：
+ 未初始化的全局变量（.bss段）
  + bss类型的全局变量只占运行时的内存空间，而不占用文件空间
+ 初始化过的全局变量（.data段）
  + data类型的全局变量是即占文件空间，又占用运行时内存空间
+ 常量数据（.rodata段）
  + 常量不一定就放在rodata里，有的和指令编码一起，存放在.text中
  + 其他数据（除了字符串）只要加上const关键字，就可以放入rodata段中
+ 代码（.text段）
  + 存放代码
+ 栈（stack）
+ 堆(heap)

```
int bss_array[1024*1024];
int main(){
    return 0;
}
ls -l bass.exe
objdum -h bss.exe | grep bss 
```
```
int bss_array[1024*1024] = {1};
int main(){
    return 0;
}
ls -l bass.exe
objdum -h bss.exe | grep bss 
```
查看bss段的大小和文件大小的比较

**查看linux下，程序运行时空的分配情况**
```
cat /proc/self/maps/

```

## 写的又好又快的秘诀

优化软件性能的方法一样，要优化程序员的性能，必须要找出性能瓶颈，弄清楚时间花在哪些地方，然后想办法省掉某些浪费了的时间

设计文档只是设计的结果，是设计的表现形式，没有写设计文档，并不代表没有做设计

*想赶时间，结果却花了更多时间，开始学会放松自己，有意识地让自己慢下来，在写完程序之后，会先花些时间去阅读它，一遍、两遍甚至多遍之后，才开始编译它，其实每一次读一遍，我都有不同的收获，甚至有些新的想法*

阅读代码的技巧：
+ 检查常见错误
  + 常见语法错误
  + 编程错误，内存泄漏等
+ 模拟计算机执行
+ 假想讲给朋友听


操作系统为什么要保留一块内存，而不是仅仅保留一个字节的内容？因为一般的内存管理都是按页进行管理的，根本就无法单纯保留一个字节，而至少包括一个页面。

只有不确定的地方，就写一个小程序验证一下

**在学习的过程中，还应该经常问这个问题：这个东西在什么时候能派上用场？**

简单的程序通常更可靠，在完成同样任务的情况下，越简单越好


**在C语言中，接口的朴素定义是：一组相关的回调函数以及其共享的上下文**

接口在软件设计中占非常重要的地位，它是隔离变化和降低复杂度的最有力的武器，几乎所有的设计模式都与接口有关

学习知识点并不是我们最重要的目标，知识点能帮你姐姐别人解决过的问题，但对你解决新问题未必有多大好处，真正的程序员不应当只是解决问题的贩卖者，不断从思考中参悟解决问题的方法，在加上灵活应用已经掌握的知识点，设计水平才会大大提高

*线程局部存储*

内存分配器很难写好？因为设计好的内存分配器需要考虑很多因素：
+ 最大化的兼容性
+ 最大化的可移植性
+ 浪费的空间最小化
+ 最快的速度
+ 最大化的调试功能
+ 最大化的适应性

**在面向对象的系统中，对象之间的协作关系非常复杂，不管调用函数还是发送消息，总要通过某种方式知道目标对象才行。最常见的做法就是保存目标对象的引用（或者指针）**

工具：
addr2lince :实现地址到源代码位置的转换，对于可执行文件，add2line可用，但是对于共享库，无法知道对应的源代码位置，因为addr2line只能通过地址偏移量来查找，由于共享库加载到内存的位置不确定，通过 maps文件（/proc/进程号/maps)

readline是一个用于提高基于终端的应用程序可用性的函数库

## 末尾
*作为一个程序员，必须清楚的认识到，只是千千万万程序员中的一员，通常你既不会是最好的，也不会是最差的，而只是一个普通的程序员，现实世界中已经有无数的程序，有的写的好，有的写的差，大多数程序不好也不差，因此要保持一个比较开放的心态去面对*