[线程的简介]: https://www.internalpointers.com/post/gentle-introduction-multithreading



现代计算机具有同时执行多项操作的能力。在硬件进步和更智能的操作系统的支持下，此功能使您的程序在执行速度和响应速度方面运行得更快。

编写利用这种功能的软件既有趣又棘手：它要求您了解计算机幕后发生的事情。在第一集中，我将尝试介绍**线程**的表面，**线程**是操作系统提供的用于执行这种魔术的工具之一。



## 进程和线程

现代操作系统可以同时运行多个程序。因此，您可以在浏览器（一个程序）中阅读本文，同时在媒体播放器（另一个程序）上听音乐。每个程序都称为正在执行的**进程**。操作系统知道许多软件技巧可以使一个进程与其他进程一起运行，并且可以利用底层硬件。无论哪种方式，最终结果都是您*感觉到*所有程序正在同时运行。

在操作系统中运行进程不是同时执行多个操作的唯一方法。每个进程都可以在其内部同时运行称为**线程的**子任务。您可以将线程视为进程本身的一部分。每个进程在启动时都会触发至少一个线程，这称为**主线程**。然后，根据程序/程序员的需要，可以启动或终止其他线程。**多线程**是关于在单个进程中运行多个线程。

例如，您的媒体播放器可能运行多个线程：一个用于渲染界面-通常是主线程，另一个用于播放音乐，依此类推。

您可以将操作系统视为包含多个进程的容器，其中每个进程都是包含多个线程的容器。在本文中，我将仅关注线程，但是整个主题很有趣，并且值得在将来进行更深入的分析。

![](/home/dji/messi/github/wuyuchun.github.io/images/posts/2021-03-30-关于多线程的简要介绍01.png)



每个进程都有自己的由操作系统分配的内存块。默认情况下，该内存无法与其他进程共享：浏览器无法访问分配给媒体播放器的内存，反之亦然。如果您运行同一进程的两个实例，即两次启动浏览器，就会发生相同的情况。操作系统将每个实例视为分配了自己单独的内存部分的新进程。因此，默认情况下，两个或多个进程无法共享数据，除非它们执行高级技巧-所谓的进程间通信（IPC）。
 与进程不同，线程共享由操作系统分配给其父进程的相同内存块：音频引擎可以轻松访问媒体播放器主界面中的数据，反之亦然。因此，两个线程可以更轻松地相互交谈。最重要的是，线程通常比进程轻：它们占用更少的资源并且创建起来更快，这就是为什么它们也被称为轻量级进程。
 线程是使您的程序同时执行多项操作的便捷方法。如果没有线程，则必须为每个任务编写一个程序，将其作为进程运行，并通过操作系统进行同步。这将更加困难（IPC棘手）并且速度更慢（进程比线程重）。



## 为什么使用线程

为什么一个进程应该使用多个线程？如前所述，并行处理可以大大加快处理速度。假设您将要在电影编辑器中渲染电影。编辑器可能足够聪明，可以将渲染操作分布在多个线程中，其中每个线程都处理最终电影的一部分。因此，如果一个线程执行一个任务要花一个小时，而两个线程执行一个任务要花30分钟。有四个线程15分钟，依此类推。
 真的那么简单吗？有三点要考虑：  并非每个程序都需要多线程。如果您的应用执行顺序操作或经常等待用户执行某项操作，则多线程可能没有那么大的益处。
您只是不向应用程序投入更多线程以使其运行更快：每个子任务都必须经过仔细考虑和设计，以执行并行操作； 不能100％保证线程将执行它们的操作真正并行，即在同一时间：它实际上取决于底层硬件上。
最后一个至关重要：如果您的计算机不同时支持多种操作，则操作系统必须伪造它们。我们将在一分钟内看到效果。现在，让我们将并发性理解为具有同时运行的任务的感知，而真正的并行性则是实际上可以同时运行的任务。



## 使得并发和并行成为可能

在中央处理单元（CPU）在您的电脑上运行的程序的辛勤工作。它由几部分组成，主要部分是所谓的核心：即实际执行计算的地方。内核一次只能运行一个操作。
 这当然是主要的缺点。因此，操作系统开发了先进的技术，使用户能够一次运行多个进程（或线程），尤其是在图形环境中，甚至在单核计算机上。最重要的一种称为抢占式多任务处理，抢占是指中断任务，切换到另一个任务，然后在以后恢复第一个任务的能力。
 因此，如果您的CPU仅具有一个内核，则操作系统的工作之一就是将单核计算能力分布到多个进程或线程中，这些进程或线程将在一个循环中依次执行。此操作给您一种幻想，即有多个程序并行运行，或者有一个程序同时执行多项操作（如果是多线程的话）。达到了并发性，但是真正的并行性（即同时运行进程的能力）仍然缺失。
 如今，现代CPU在引擎盖下拥有多个内核，每个内核一次执行独立的操作。这意味着使用两个或更多核心可以实现真正的并行性。例如，我的Intel Core i7有四个核心：它可以同时同时运行四个不同的进程或线程。
 操作系统能够检测CPU内核的数量，并为每个内核分配进程或线程。可以将线程分配给操作系统喜欢的任何核心，并且这种调度对于正在运行的程序是完全透明的。此外，在所有内核都忙的情况下，抢先式多任务处理可能会启动。这使您能够运行比计算机中实际可用数量或内核多的进程和线程。





## 单核上的多线程有意义吗?

单核计算机上无法实现真正的并行性。但是，如果您的应用程序可以从中受益，那么编写多线程程序仍然有意义。当一个进程使用多个线程时，抢占式多任务处理可以使应用程序运行，即使其中一个线程执行的是慢速任务或阻塞任务。

假设您正在使用一个桌面应用程序，该应用程序从非常慢的磁盘中读取一些数据。如果仅使用一个线程编写程序，则整个应用程序将冻结，直到磁盘操作完成：等待磁盘唤醒时，浪费了分配给唯一线程的CPU电源。当然，操作系统除了运行该进程外还运行许多其他进程，但是您的特定应用程序不会取得任何进展。

让我们以多线程的方式重新考虑您的应用程序。线程A负责磁盘访问，而线程B负责主接口。如果线程A由于设备速度缓慢而陷入等待状态，则线程B仍可以运行主界面，从而使程序保持响应速度。这是可能的，因为具有两个线程，操作系统可以在它们之间切换CPU资源，而不会卡在较慢的线程上。



## 更多线程,更多问题

众所周知，线程共享与其父进程相同的内存块。这使得它们中的两个或多个在同一应用程序内交换数据极其容易。例如：电影编辑器可能包含包含视频时间轴的共享内存的很大一部分。此类共享内存正在由多个工作线程读取，这些工作线程指定用于将影片渲染为文件。它们都只需要一个指向该内存区域的句柄（例如，指针），即可从其中读取内容并将渲染的帧输出到磁盘。
 只要两个或多个线程从同一内存位置读取，事情就可以顺利运行。当其中至少一个写入共享内存，而其他人正在读取共享内存时，麻烦就开始了。此时可能会出现两个问题：  

- 数据争用—写线程修改内存时，读线程可能正在读取内存。如果编写器尚未完成工作，则读取器将获得损坏的数据；  
- 竞争条件-读者线程应仅在作者编写后才能读取。如果相反的情况发生了怎么办？比数据竞争更微妙的是，竞争条件是大约两个或多个线程以不可预测的顺序执行其工作，而实际上应该按正确的顺序执行操作才能正确完成。您的程序可以触发争用条件，即使已针对数据争用提供了保护。



## 线程安全

如果一段代码正常工作，那么它就被认为是线程安全的，也就是说，即使许多线程同时执行它，也不会出现数据争用或竞争条件。您可能已经注意到，某些编程库将自己声明为线程安全的：如果要编写多线程程序，则要确保可以在不同线程之间使用任何其他第三方函数而不会触发并发问题。



## 数据竞争的基本原因

我们知道，CPU内核一次只能执行一条机器指令。这样的指令被称为**原子的，**因为它是不可分割的：它不能分解成较小的操作。希腊语“ atom”（ἄτομος; atomos）的意思是*不可切割的*。

不可分割的性质使原子操作本质上是线程安全的。当一个线程对共享数据执行原子写操作时，其他任何线程都无法读取修改的一半。相反，当线程对共享数据执行原子读取时，它将读取单个时间点出现的整个值。线程无法*跳过*原子操作，因此不会发生数据争用。

坏消息是，绝大部分的操作都是非原子的。即使是像`x = 1`某些硬件上的琐碎任务，也可能由多个原子机器指令组成，从而使该任务本身整体上不是原子的。因此，如果一个线程`x`在另一个线程执行分配的同时读取该数据，则会触发数据争用。



## 竞争条件的基本原因

抢占式多任务处理使操作系统可以完全控制线程管理：它可以根据高级调度算法启动，停止和暂停线程。您作为程序员不能控制执行的时间或顺序。实际上，不能保证像这样的简单代码：

```nocode
writer_thread.start()
reader_thread.start()
```

将以该特定顺序启动两个线程。多次运行该程序，您会注意到它在每次运行中的行为方式不同：有时写入程序线程首先启动，有时读取程序则启动。如果您的程序需要编写器始终在读取器之前运行，那么您肯定会遇到竞争状况。

这种行为称为**不确定性**：结果每次都会更改，您无法预测。调试受竞争条件影响的程序非常烦人，因为您不能始终以受控方式重现该问题。



## 教线程相处:并发控制

数据竞赛和竞争条件都是现实世界中的问题：有些人甚至[因此而丧生](https://en.wikipedia.org/wiki/Therac-25)。容纳两个或多个并发线程的技术被称为**并发控制**：操作系统和编程语言提供了几种解决方案。最重要的是：

- **同步**-一种确保一次只能由一个线程使用资源的方法。同步是指将代码的特定部分标记为“受保护”，以便两个或多个并发线程不会同时执行它，从而破坏了共享数据。
- **原子操作**-由于操作系统提供的特殊指令，一堆非原子操作（如前面提到的分配）可以转换为原子操作。这样，无论其他线程如何访问，共享数据始终保持有效状态。
- **不可变数据**-共享数据被标记为不可变，没有任何可以更改的数据：仅允许从中读取线程，从而消除了根本原因。众所周知，只要不修改线程，线程就可以安全地从相同的内存位置读取。这是[函数式编程](https://en.wikipedia.org/wiki/Functional_programming)的主要原理。