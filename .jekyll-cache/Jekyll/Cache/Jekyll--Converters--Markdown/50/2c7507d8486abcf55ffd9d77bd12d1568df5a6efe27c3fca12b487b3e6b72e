I"à<p>listi</p>

<p>[10:01 PM]</p>

<h1 id="å‰è¨€">å‰è¨€</h1>

<blockquote>
  <p>åè¨€ï¼šç¨‹åº = æ•°æ®ç»“æ„ + ç®—æ³•
æ‰€ä»¥æœ€è¿‘æŠŠã€Šç¨‹åºå‘˜çš„å®ç”¨ç®—æ³•ã€‹å¥½å¥½çœ‹</p>
</blockquote>

<h1 id="å•å‘é“¾è¡¨">å•å‘é“¾è¡¨</h1>
<p>é“¾è¡¨ä¹Ÿè®¸æ˜¯æ¯”è¾ƒç®€å•çš„æ•°æ®ç»“æ„äº†ï¼Œå› ä¸ºäººçš„è®¤çŸ¥ä¸œè¥¿ä¾é çš„æ˜¯æ¨¡å¼ï¼Œé“¾è¡¨èƒ½å¾ˆå¥½çš„å¯¹åº”ç”Ÿæ´»çš„ä¸­è½¦é“¾è¿™ä¸ªä¸œä¸œäº†ã€‚</p>

<h2 id="é“¾ä¸­çš„ä¸€ç¯">é“¾ä¸­çš„ä¸€ç¯</h2>
<p>å…³é”®æ˜¯å¦‚ä½•è¡¨ç¤ºé“¾è¡¨ä¸­çš„ä¸€ç¯ï¼Œç»å…¸çš„å®šä¹‰å¦‚ä¸‹ï¼š</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//èŠ‚ç‚¹çš„å®šä¹‰
struct Node
{
	char *City;
	int Temp;
	struct Node *next;
};

typedef struct Node * Link;

</code></pre></div></div>

<h2 id="æ“ä½œ">æ“ä½œ</h2>
<p>æœ‰äº†æ•°æ®ç»“æ„ï¼Œæ€»è¦å¯¹æ•°æ®è¿›è¡Œæ“ä½œï¼Œä¸‹é¢ç»™å‡ºå•å‘é“¾è¡¨çš„ä¸€äº›å¸¸è§„æ“ä½œã€‚</p>

<p>1ã€åˆå§‹åŒ–æ“ä½œ</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void CreateLite()
{
	head = NULL;  //å¤´èŠ‚ç‚¹
	iNodeCount = 0; //èŠ‚ç‚¹æ•°é‡
}
</code></pre></div></div>
<p>2ã€å¢åŠ èŠ‚ç‚¹
å‘ä¸€ä¸ªé“¾è¡¨å¢åŠ ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå…¶å®å¾ˆç®€å•ï¼Œä½†æ˜¯æœ‰å‡ ç§æƒ…å†µè¦ç‰¹æ®Šå¤„ç†ï¼šæ¯”å¦‚ç©ºè¡¨ï¼ˆè¯´ç™½å°±æ˜¯å¢åŠ ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼‰ï¼Œæœ€åˆçš„æ—¶å€™ï¼Œéƒ½æ˜¯å¯¹å…¶è¿›è¡Œç‰¹æ®Šå¤„ç†ã€‚</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int AddNodeAscend(Link to_add)
{
	Link  pn,
		  pre,
		  curr;
	struct Node dumy;  //ç”Ÿæˆä¸€ä¸ªèŠ‚ç‚¹ å¾ˆå¥½çš„ç­–ç•¥ï¼ï¼ï¼ï¼ï¼

	pn = (Link)malloc(sizeof( struct Node));
	if ( NULL == pn )
	{
		return 0;
	}
	memcpy( pn , to_add ,sizeof(struct Node));

	dumy.next = head;
	pre = &amp;dumy;
	curr = head;

	int i;
	for (; curr != NULL ; pre = curr, curr = curr-&gt;next)
	{
	}
	pre-&gt;next = pn;
	pn-&gt;next = curr;

	head = dumy.next;
	return 1;
}
</code></pre></div></div>
<p>3ã€åˆ é™¤èŠ‚ç‚¹</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int DeleNode(Link to_Del)
{
	Link curr,
		 pre;
	int i;

	if ( NULL == head )
	{
		return 0;
	}

	for ( pre = NULL , curr = head; curr != NULL;pre = curr, curr = curr-&gt;next)
	{
		i = NodeCmp(to_Del, curr);
		if ( curr != NULL &amp;&amp; 0 ==i )
		{
			if ( pre)
			{
				pre-&gt;next = curr-&gt;next;
			}
			else
			{
				head = curr-&gt;next;
			}

			FreeNode(curr);	
			iNodeCount -= 1;
			return 1;
		}
	}
	return 0;
}
</code></pre></div></div>
<p>4ã€é‡Šæ”¾å†…å­˜æ“ä½œï¼ˆå¾ˆå…³é”®ï¼Œä¸è®©å†…å­˜æ³„éœ²ï¼ï¼‰</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void FreeNode(Link to_free)
{
	free( to_free-&gt;City );
	free(to_free);
}
</code></pre></div></div>

<h1 id="æ€»ç»“">æ€»ç»“</h1>
<p>å•å‘é“¾è¡¨è¾ƒä¸ºç®€å•ï¼Œå¾ˆå¥½ä½¿ç”¨ï¼Œä½†æ˜¯ä¹Ÿå­˜åœ¨ä¸€å®šçš„å±€é™æ€§ã€‚</p>

<h1 id="é™„å½•ç»™å‡ºå®Œæ•´çš„å®šä¹‰">é™„å½•ï¼ˆç»™å‡ºå®Œæ•´çš„å®šä¹‰ï¼‰</h1>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#ifndef LINK_H
#define LINK_H

//é“¾è¡¨çš„å£°æ˜
struct Node
{
	char *City;
	int Temp;
	struct Node *next;
};

typedef struct Node * Link;

int AddNodeAscend(Link to_add); //ä»¥é™åºçš„å½¢å¼åŠ å…¥ä¸€ä¸ªèŠ‚ç‚¹
void CreateLite( void ); //åˆå§‹åŒ–ä¸€ä¸ªé“¾è¡¨
int DeleNode( Link to_Del); //åˆ é™¤ä¸€ä¸ªèŠ‚ç‚¹
int DuplicateNode( Link , Link ); //å¤„ç†å¤šé‡æ’å…¥
void FreeNode(Link to_free); //é‡Šæ”¾ä¸€ä¸ªèŠ‚ç‚¹
void ShowNode( void ); //å½¢å¼èŠ‚ç‚¹
int NodeCmp(Link , Link ) ; //æ¯”è¾ƒä¸¤ä¸ªèŠ‚ç‚¹
#endif
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include "Link.h"
#include &lt;stdlib.h&gt;
#include &lt;string&gt;
Link head;
int iNodeCount;

int AddNodeAscend(Link to_add)
{
	Link  pn,
		  pre,
		  curr;
	struct Node dumy;  //ç”Ÿæˆä¸€ä¸ªèŠ‚ç‚¹

	pn = (Link)malloc(sizeof( struct Node));
	if ( NULL == pn )
	{
		return 0;
	}
	memcpy( pn , to_add ,sizeof(struct Node));

	dumy.next = head;
	pre = &amp;dumy;
	curr = head;

	int i;
	for (; ; pre = curr, curr = curr-&gt;next)
	{
		if ( NULL == curr )
		{
			break; //åˆ°è¾¾æœ«å°¾
		}
		i = NodeCmp(pn,curr);
		if ( i &lt;= 0 )
		{
			break;
		}
	}

	if ( curr &amp;&amp; 0 == i)
	{
		if ( 0 == DuplicateNode(curr ,pn ) )
		{
			return 1;
		}
	}

	pre-&gt;next = pn;
	pn-&gt;next = curr;

	head = dumy.next;
	return 1;
}

int DuplicateNode( Link inLinst, Link duplicate)
{
	FreeNode(duplicate);
	return 0;
}

int DeleNode(Link to_Del)
{
	Link curr,
		 pre;
	int i;

	if ( NULL == head )
	{
		return 0;
	}

	//curr = head; 
	//i = NodeCmp(to_Del,curr);

	for ( pre = NULL , curr = head; curr != NULL;pre = curr, curr = curr-&gt;next)
	{
		i = NodeCmp(to_Del, curr);
		if ( curr != NULL &amp;&amp; 0 ==i )
		{
			if ( pre)
			{
				pre-&gt;next = curr-&gt;next;
			}
			else
			{
				head = curr-&gt;next;
			}

			FreeNode(curr);	
			iNodeCount -= 1;
			return 1;
		}
	}
	return 0;
}

int NodeCmp(Link a, Link b)
{
	if ( a-&gt;Temp != b-&gt;Temp )
	{
		return a-&gt;Temp - b-&gt;Temp;
	}
	else
	{
		return strcmp(a-&gt;City ,b-&gt;City);
	}
}

void CreateLite()
{
	head = NULL;
	iNodeCount = 0;
}

void FreeNode(Link to_free)
{
	free( to_free-&gt;City );
	free(to_free);
}

void ShowNode()
{
	Link pn;
	int count, median;
	
	for ( count = 0 ,pn = head;pn;pn = pn-&gt;next)
	{
		count +=1;
	}

	median = count/2+1;

	if ( count)
	{
		count = 0;
		for ( pn = head; pn;pn = pn-&gt;next)
		{
			printf("%-20s: %3d",pn-&gt;City,pn-&gt;Temp);
			count += 1;
			if ( count == median )
			{
				printf("----Median-----");
			}
			printf("\n");
		}

	}
	else
	{
		printf("Empty list\n");
	}
}
</code></pre></div></div>
:ET